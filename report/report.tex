%
% $Id$
% $Author$
% $Date$
% $Rev: 34 $
%

\documentclass{scrartcl}
\KOMAoptions{fontsize=11pt}
%\KOMAoptions{BCOR=0.25mm}
%\usepackage[left=3.1cm, right=3.1cm]{geometry}

\usepackage{mathdesign}
\usepackage[no-math]{fontspec}
\defaultfontfeatures{Ligatures=TeX}
\setmainfont[Numbers=OldStyle]{Latin Modern Roman}
%\setmainfont[Numbers=OldStyle]{CMU Serif}
%\setmainfont[Numbers=OldStyle]{Gentium}
%\setmainfont[Numbers=OldStyle]{EB Garamond}
\setsansfont[Numbers=OldStyle]{CMU Sans Serif}
%\setsansfont{Droid Sans}
%\setmonofont{CMU Typewriter Text}
\setmonofont[Scale=0.9]{Droid Sans Mono}
%\setmonofont{DejaVu Sans Mono}
\newfontfamily\CodeFont[Scale=0.85]{DejaVu Sans Mono}
%\newfontfamily\CodeFont[Scale=0.85]{Consolas}
%\newfontfamily\CodeFont[Scale=0.85]{Anonymous Pro}

\usepackage[english,ngerman,russian]{babel}

\usepackage{commath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}

\usepackage{amsthm}
\usepackage{thmtools}
\usepackage{etoolbox}
\usepackage{changepage}

\declaretheorem[style=definition,name=Definition]{define}
\declaretheorem[style=plain]{theorem}
\declaretheorem[sibling=theorem]{lemma}
%\BeforeBeginEnvironment{theorem}{\begin{adjustwidth}{1cm}{1cm}}
%\AfterEndEnvironment{theorem}{\endadjustwidth}
%\AfterEndEnvironment{define}{\noindent\ignorespaces}
%\makeatletter
%\def\@endtheorem{\endtrivlist}%
%\makeatother

\usepackage{caption}
\usepackage{ragged2e}

\usepackage{graphicx}
%\usepackage[export]{adjustbox}
%\usepackage{epstopdf}
%\epstopdfDeclareGraphicsRule{.tif}{png}{.png}{convert #1 \OutputFile}
%\AppendGraphicsExtensions{.tif}
\usepackage{luamplib}
\usepackage{etoolbox}
\preto\mplibcode{\center\leavevmode}
\appto\endmplibcode{\endcenter}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{subfig}
\usepackage{sidecap}
\usepackage[bottom]{footmisc}

\usepackage{xcolor}
\definecolor{Gray}{gray}{0.9}
\definecolor{blue}{rgb}{0,0,0.3}
\definecolor{green}{rgb}{0,0.3,0}
\definecolor{codeblue}{rgb}{0,0,0.3}
\definecolor{codegreen}{rgb}{0,0.3,0}
\definecolor{codered}{rgb}{0.3,0,0}

\usepackage{listings}
\usepackage{needspace}
\lstset{%
  basicstyle=\CodeFont\footnotesize, %\footnotesize\ttfamily,
  frame=single, %line/leftline/single
  aboveskip=\topsep,
  belowskip=\topsep,
  breakatwhitespace=true,
  showstringspaces=false,
  breaklines=true,
  commentstyle=\itshape\color{codegreen},
  keywordstyle=\bfseries\color{codeblue},
  stringstyle=\color{codered},
  captionpos=t\/
}
\captionsetup[lstlisting]{font=footnotesize}
\newcommand{\mylisting}[2][]{%
  \lstinputlisting[caption={\texttt{\detokenize{#2}}},#1]{#2}%
}

%\usepackage{kantlipsum}
%\usepackage{blindtext}
\usepackage{marginnote}
\newcommand{\annotation}[1]{\marginpar{\small\itshape\color{green}#1}}

\usepackage{booktabs}
\usepackage{longtable}
\usepackage{color, colortbl}
\usepackage{multirow}
\usepackage{varwidth}
\usepackage{pgfplotstable}

\usepackage[pdfauthor={M. Deineko},
            pdfproducer={lualatex},
            pdfcreator={LaTeX},
            colorlinks=true,
            linkcolor=blue,
            urlcolor=blue,
            citecolor=blue,
            linktoc=section,
            unicode=true
            ]{hyperref}
\hypersetup{pdftitle=Two Exponential Neighbourhoods}

\usepackage[title,page,titletoc]{appendix}
\newcommand*{\Appendixautorefname}{Appendix}
\usepackage{cleveref}

\usepackage{verbatim}
\usepackage{cprotect}

\usepackage{afterpage}
%\makeatletter
%\def\verbatim@font{\normalfont\itshape}
%\makeatother
\newcommand\blankpage{%
  \null%
  \thispagestyle{empty}%
  %\addtocounter{page}{-1}%
  \vspace*{\fill}
  \centering
  {\em {\small
  This page would have been intentionally left blank had we not chosen to
  \href{https://en.wikipedia.org/wiki/Recursion}{mention it}.
  }}%
  %\verbatiminput{|"/usr/games/fortune"}
  \vspace{\fill}%
  \newpage
}

\usepackage[backend=biber,style=alphabetic]{biblatex}
\usepackage{csquotes}
%\usepackage[fixlanguage]{babelbib}
\addbibresource{references.bib}
\usepackage[nottoc]{tocbibind}

%\usepackage[toc]{multitoc}
\usepackage[subfigure]{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}

\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}

\begin{document}

\selectlanguage{english}

\title{Two Exponential Neighbourhoods}
\subtitle{Pyramidal and strongly balanced Traveling Salesman Problem and heuristics --- theory and implementation}
\input{authors.tex}
\date{\today}
\maketitle

\begin{abstract}
  Pyramidal tours form a well known polynomially solvable subclass of TSP\@.
  In this paper, we present first implementation of a related tours family,
  show extension of both to local search heuristics and compare results thus obtained.
\end{abstract}

\thispagestyle{empty}

%\setlength{\cftbeforetoctitleskip}{-2em}
\tocloftpagestyle{empty}
\tableofcontents
\afterpage{\blankpage}

%\setlength{\parindent}{0cm}

\clearpage

\section{Theory}
%\dictum[Honore de Balzac]{To get a traveling salesman drunk is the height of impossibility.}
\dictum[Sherlock Holmes]{Nothing clears up a case so much as stating it to another person.}

\subsection{Notation}

\annotation{What should be the prerequisites?}
In this paper we shall follow canonical definition of TSP as a minimization problem
on a complete, directed graph with node set $\{1,2,\ldots,n\} \cong {\mathbb Z}_n \equiv {\mathbb Z}/n{\mathbb Z}$,
tour set being $S_n$,
where one can associate permutations
$\left( \begin{smallmatrix}
    1 & 2 & \cdots & n \\
    k_1 & k_2 & \cdots &  k_n
 \end{smallmatrix} \right)
 \in S_n
$ with tours $\left( k_1, k_2, \ldots ,k_n, k_1 \right)$,
and tour length of $\tau = \left( k_1, \ldots, k_n, k_1 \right)$ given by
$\operatorname{len}(\tau) = \sum_{i \in {\mathbb Z}_n} C_{i,i+1}$,
where $C$ is a distance matrix given either explicitly or by some metric.
Henceforth we shall consider only non-negative distance instances.

\subsection{Pyramidal tours}

\annotation{Who was first?}
Pyramidal tours constitute a classic example of a TSP class where an
optimum solution for an exponential tours set (also, a neighbourhood) can
be found in polynomial time \cite{bellman,lawler,gilmore}.

\begin{define}
  A path $\pi = \left( k_1, \ldots, k_m \right)$ is called {\bfseries simple}
  if it consists only of distinct nodes, except, possibly, end nodes $k_1$ and $k_m$.
  In case where $k_1 = k_m$ we shall call such a path {\bfseries closed}.
\end{define}
\begin{define}[Pyramidal Tour]
  A simple path $\pi = \left( k_1, \ldots, k_p, l_1, \ldots, l_q \right), \; p+q \geq 1,$
  is called {\bfseries pyramidal} if
  $k_i < k_j, l_i > l_j \; \forall i < j$.
  A (simple) closed path is called a {\bfseries tour}.
\end{define}
\noindent
Since all tours associated with $S_n$ have the form $\left(1, k_1, \ldots,
k_p, n, l_1, \ldots, l_q, 1 \right)$, it follows that the number of all
such tours is $2^{n-2}$.  Also note how the graph of such a permutation
considered a function ${\mathbb Z}_n \rightarrow {\mathbb Z}_n$ resembles a
pyramid.

\annotation{Here a nice figure of a pyramidal tour and a pyramid shall be.}
\begin{figure}[htbp]
\centering%
\begin{mplibcode}
  beginfig(0)
    pair p[];
    p1 = (0,0); p2 = (100,0); p3 = (200,0); p4 = (300,0); p5 = (400,0);
    pair c[];
    c1 = (50,20); c2 = (210,30); c3 = (250,-10); c4 = (100,-20);
    path a;
    a = p1 .. controls c1 ..
        p2 .. controls c2 ..
        p4 ..
        p5 .. controls c3 ..
        p3 ..  controls c4 ..
        cycle ;
    for i = 1 upto length a:
      dotlabel.top(decimal i, p[i]);
      drawarrow subpath (i-1,i) of a withcolor 0.2;
    endfor
  endfig;
\end{mplibcode}
\ 
\caption{A pyramidal tour over $K_5$.}
\end{figure}

\subsubsection{Pyramidal tours and polynomial time}

It turns out that for this particular exponential neighbourhood a simple dynamic programming
scheme delivers a polynomial solution.
\annotation{Is there any difference at all between sTSP and aTSP here?}
(For simplicity, we shall consider symmetric TSP (sTSP).)
For a sTSP of size $n$, let
\begin{align*}
  \Phi\left(i,j\right) \ldots \; & \text{shortest pyramidal path} \left(i,k_1,\ldots,k_p,j\right) \\
                      & \text{s.t.} \; \left\{ k_1,\ldots,k_p \right\} = \left\{ k,\ldots,n \right\} \\
                      & \text{where} \; k = \max\left\{i,j\right\}+1.
\end{align*}
One can easily see that $\Phi(1,1)$ is the optimum of all pyramidal tours in $S_n$ (one-based).
\[
  \Phi\left(i,n\right) = \left(i,n\right) \; \text{and} \; \Phi\left(n,j\right) = \left(n,j\right).
\]
\annotation{A construction illustration would be in order here.}
Now note that one can build an arbitrary pyramidal path by considering nodes' positions in increasing order:
given a partial tour (a pyramidal path) $\left(1,\ldots,i,j,\ldots,1\right)$ which increases to $i$ and
decreases from $j$, the next element ($\max\left\{i,j\right\}+1$) has to lie adjacent to $i$ or $j$.
Since every pyramidal tour over $K_n$ can be constructed in this manner, it follows that
\begin{gather*}
  \Phi\left(i,j\right) = \argmin_{\tau \in T}\operatorname{len}\left(\tau\right) \\
  \text{where} \; T = \left\{ \left( i,k \right) \oplus \Phi(k,j), \Phi(i,k) \oplus \left( k,j \right) \right\} \\
  \text{and} \; \oplus \; \ldots \; \text{path concatenation}.
\end{gather*}
We hence arrive at
\begin{theorem}
  For $K_n$, amongst $2^{n-3}$ pyramidal tours an optimum can be found in $\mathcal O(n^2)$ steps.
\end{theorem}
\begin{proof}
  For $K_n$, computing the optimum now requires computing not more than $\Phi\left(i,j\right)$
  for all pairs $\left(i,j\right)$.
\end{proof}

\begin{figure}[htbp]
\centering
\includegraphics[width=0.59\textwidth]{../plot/out/trace_pyr.pdf}
\caption{A trace of our implementation's pyramidal search graph traversal over $K_5$.}
\end{figure}

\subsubsection{Local search heuristics}

\annotation{Demidenko conditions: is a description necessary/interesting?}
While determining if a given TSP instance is pyramidal is NP-hard \cite{baki},
a number of polynomially testable classes which are pyramidally solvable exist \cite{baki,gilmore} ---
still, those are not widely common.

Pyramidal search can also be extended to a local search heuristic:
note first how the tour obtained depends on node numbering.
Now let $\operatorname{pyr}(C)$ denote best pyramidal tour given a distance matrix $C$
and, given a tour $\tau$, $\sigma_\tau \left(C\right)$ be the permutation associated with $\tau$
applied to rows and columns of $C$ (i.e. renumbering of nodes).
Let
\[
  h_C \; : \;
    \tau \mapsto \left(
      \sigma_{\tau}^{-1} \circ
      \operatorname{pyr} \circ
      \sigma_{\tau}
    \right)
    \left( C \right).
\]
Then $h_C\left(\left(1,2,\ldots,n,1\right)\right) = \operatorname{pyr}\left(C\right)$.
Since $\left(1,2,\ldots,n,1\right)$ is a pyramidal tour,
\[
  \operatorname{len} \circ h_C \leq \operatorname{len}
\]
holds everywhere.
In this way, iterating from $\left(1,2,\ldots,n,1\right)$ to a fixed point of $h_C$ yields a
local search heuristic.

It had been shown \cite{belperm} that we can significantly improve on this by enhancing
$\operatorname{pyr}$ to choose from $n$ shortest pyramidal tours obtained by applying
cyclic permutations to initial node ordering.

\subsection{Strongly balanced tours}
\annotation{TODO}

Balanced and strongly balanced tours.
Description will refer to pyramidal case.
Definition via construction.
Our implementation is first.
Also, have to have nice pictures.

\subsubsection{Strongly balanced tours and linear time}
\annotation{TODO}

Number of tours is $\Omega(2^n)$.
Dynamic programming recursion follows from construction.
Tree width is capped for a given maximum node size, hence linear time \cite{fpneighb}.
Experiment: tree area grows fast (shown in \autoref{tbl:nodeTypes}),
tree width not computed (BFS would make this natural).

\setlength{\aboverulesep}{0pt}
\setlength{\belowrulesep}{0pt}
\renewcommand{\tabcolsep}{9pt}
\setlength{\extrarowheight}{1.1ex}
\newcolumntype{g}{>{\columncolor{Gray}}c}

\begin{table}[htpb]
\centering
    \mbox{%
      \pgfplotstabletypeset[
        col sep=space,
        std=-10:10,
        every head row/.style={output empty row},
        every head row/.style={%
          before row={\toprule},
          after row={\midrule}
        },
        display columns/0/.style={%
          column name={\bfseries Node size limit},
          column type={g}
        },
        display columns/1/.style={%
          column name={\bfseries Node types},
          column type={r}
        },
        display columns/2/.style={%
          column name={\bfseries Stable at size},
          column type={g}
        },
        every last row/.style={after row=\bottomrule},
        %multicolumn names,
      ]{../plot/data/num\string_types.csv}%
    }
\caption{Node types encountered.}%
\label{tbl:nodeTypes}%
\end{table}

\begin{figure}[htbp]
\makebox[\textwidth][c]{%
  \includegraphics[width=1.21\textwidth]{../plot/out/trace_bal.pdf}
}
\caption{%
  A trace of our implementation's strongly balanced search graph traversal over $K_8$.  Here, maximum node size is 2.
}
\end{figure}

\subsubsection{Local search heuristics}
\annotation{TODO}

Applicability: Relaxed Supnick matrices with additional property.
Heuristics concept same as in pyramidal case, permutations adjusted.
Adaptive search seems better than always choosing from $2n+1$ str.-balanced-cyclic permutations.
Sources: \cite{fpclass}.

\clearpage
\section{Implementation}
%\dictum[Edward V Berard]{Walking on water and developing software from a specification are easy if both are frozen.}
%\dictum[L. Peter Deutsch]{To iterate is human, to recurse divine.}
\dictum[Donald Knuth]{You’re bound to be unhappy if you optimize everything.}

\subsection{Brief overview}
\annotation{TODO}

Written in {\ttfamily Standard ML}.
Usable via REPL, standalone executable or shared library.
Tested under multiple software (see \autoref{app:compiler}) and OS/hardware platforms --
Linux (amd64) and Windows (x86) (MinGW-crosscompiled).

General dynamic programming results implementation via search graph traversal (simple depth first search),
sacrificing performance for ease of extendibility (provide LOC count).
BFS might have been somewhat faster, but for our research dfs is enough.
Memoization via hash tables.

\annotation{Rename repo?}
This project's sources are available
\href{https://bitbucket.org/mad_hatter/rstsp/}{online}\footnote{\url{https://bitbucket.org/mad_hatter/rstsp/}}.

\subsection{Runtime behaviour}
\annotation{TODO}

Clearly pronounced linear runtime for str.~balanced search, apparently heavy overhead penalty.
Pyramidal faster but str.~balanced eventually takes over.
See \autoref{fig:benchRAND}.
Memory usage?

\begin{figure}[htbp]
\null\hfill%
\subfloat[higher node sizes]{%
  \includegraphics[width=0.49\textwidth]{../plot/out/mlton_time_random_low.pdf}
}\hfill\null
\null\hfill%
\subfloat[medium node sizes]{%
  \includegraphics[width=0.49\textwidth]{../plot/out/mlton_time_random_fast.pdf}
}\hfill\null\\
\null\hfill%
\subfloat[low node sizes]{%
  \includegraphics[width=0.59\textwidth]{../plot/out/mlton_time_random_steady.pdf}
}\hfill\null\\
\null\hfill%
\subfloat[pyramidal vs str.~balanced/m3]{%
  \includegraphics[width=0.49\textwidth]{../plot/out/mlton_time_random_med.pdf}
}\hfill\null
\null\hfill%
\subfloat[pyramidal vs str.~balanced/m4]{%
  \includegraphics[width=0.49\textwidth]{../plot/out/mlton_time_random_hi.pdf}
}
\hfill\null
\caption{Single traversal running times (Linux 3.10.17 ({\ttfamily x86\_64}) @ i5-2520M).}
\label{fig:benchRAND}
\end{figure}

\subsection{Tour benchmarks}

\annotation{TODO}
Describe results, add Relaxed Supnick matrices (!), prettier histograms, plot iterations behavior?.
See \autoref{fig:benchTSPLIB}.

\begin{figure}[htbp]
\null\hfill%
\subfloat[random --- tour length]{%
  \includegraphics[width=0.69\textwidth]{../plot/out/random_val.pdf}
}\hfill\null\\
\null\hfill%
\subfloat[tsplib \& vlsi --- tour quality]{%
  \includegraphics[width=0.69\textwidth]{../plot/out/tsplib_val.pdf}
}\hfill\null\\
\null\hfill%
\subfloat[tsplib \& vlsi --- time needed]{%
  \includegraphics[width=0.69\textwidth]{../plot/out/tsplib_time.pdf}
}\hfill\null
\caption{Benchmarks --- small instances.}
\label{fig:benchTSPLIB}
\end{figure}

\clearpage
\section{Conclusions}
\dictum[Arthur Bloch]{Enough research will tend to support your conclusions.}

\subsection{Results obtained}
\annotation{TODO}
First implementation of str.~balanced search.
Some benchmarks.
Preprocessing no gain.

\begin{figure}[htbp]
%\begin{wrapfigure}{r}{0.5\textwidth}
\centering
\includegraphics[width=0.54\textwidth]{./tsp.png}
\caption*{\captionsize Source: \small \url{https://xkcd.com/399/}.}
%\end{wrapfigure}
\end{figure}

\subsection{Areas for further research}
\annotation{TODO}

Heuristics better for aTSP\@?
Untested: other metrics or higher dimensions, dedicated implementations' performance.
Further heuristics combinations.
Branch cutting.
Different permutations set for str.~balanced tours?

\subsection{Dynamic programming algorithms and concurrency}
\annotation{TODO}

Dedicated implementations (pyramidal: bottom up easy) fast, but not always feasible (str.~balanced: machine-generated).
Naive concurrency (see the {\ttfamily experimental} code) not easily applicable in general case (dense search tree).
Potentially fruitful approaches: tuple spaces, message passing languages, etc
(PolyML/Linda?, manticore, jocaml, mythryl, aliceml, clojure/clotilde, scala/akka, $\ldots$).

%\input{problem1.tex}

%%
%% BS
%%
%Let
%\[ \Phi_k\left(\big\{ \{a_1,b_1\}, \ldots ,\{a_p,b_p\} \big\} \right) \]
%denote shortest (in total length) balanced paths set containing points $1 \ldots k$
%with $a_i, b_i$ being the paths' endpoints
%and
%\[ B\left(\big\{ \{a_1,b_1\}, \ldots ,\{a_p,b_p\} \big\}\right) = \bigcup_i\{a_i,b_i\}.\]
%%Then following holds:
%\begin{enumerate}
%  \item
%\[
%  \Phi_k\left(\big\{ \{a_1\}, \ldots , \{a_k\} \big\} \right) =
%  \left\{ \left< a_1 \right> , \ldots , \left< a_k \right> \right\}
%\]
%  \item
%\[
%  \Phi_k\left(\big\{ s_1, \ldots , s_p, \{k\} \big\} \right) =
%  \Phi_{k-1}\left(\big\{ s_1, \ldots , s_p \big\}\right) \cup
%  \left\{\left<k\right>\right\}
%\]
%  \item
%\[
%  \Phi_k\left(\big\{ s_1, \ldots , s_p, \{r,k\} \big\} \right) =
%  append\left(\Phi^{*},z^{\ast},k\right)
%\]
%where
%\[
%  \Phi^{*} = \Phi_{k-1}\left(\big\{ s_1, \ldots , s_p, \{r,z^{*}\} \big\} \right)
%\]
%\[
%  z^{*} = \argmin_{z \in [1,\ldots,m]}{
%    \left(
%      length \;
%      \Phi_{k-1}\left(\big\{ s_1, \ldots , s_p, \{r,z\} \big\} \right)
%      + d(z,k)
%    \right)
%  }
%\]
%\[
%  m = \min B\left(\{s_1, \ldots ,s_p\}\right) \cup \{k\} - 1
%\]
%  \item
%\[
%  \Phi_k\left(\left\{ s_1, \ldots , s_p \right\} \right) =
%  \;\text{with}\;
%  k \notin B\left({s_1,\ldots,s_p}\right)
%\]
%is then chosen from two possible solutions:
%\begin{enumerate}
%  \item
%\[
%  merge\left(\Phi_{q^{*}},z^{*},z^{**},k\right)
%\]
%where
%\[
%  \Phi_{q^{*}} = \Phi_{k-1}\left(\big\{ s_1, \ldots , s_{q^{*}-1},
%  \{z^{*},a^{*}\}, \{b^{*},z^{**}\}, s_{q^{*}+1}, \ldots, s_p \big\} \right)
%\]
%\[
%  s_{q^{*}} = \{a^{*},b^{*}\}
%\]
%\[
%  (q^{*}, z^{*},z^{**}) = \argmin_{
%    \substack{q \in [1,p] \\\
%              z^\prime \in [1,\ldots,m-1] \\\
%              z^{\prime\prime} \in [z^\prime+1, m-1]}}{
%    \mkern-18mu \Phi_{k-1}\left(\big\{ s_1, \ldots , s_{q-1},
%    \{z^{\prime},a\}, \{b,z^{\prime\prime}\},
%    s_{q+1}, \ldots ,s_p \big\} \right)
%    \! + \! d(z^\prime,a) \! + \! d(z^{\prime\prime},b)
%  }
%\]
%\[
%  m = \min B\left(\{s_1,\ldots,s_p\}\right)
%\]
%  \item
%\[
%  merge\left(\Phi^{*},z^{*},z^{**},k\right)
%\]
%for
%\[
%  s_p = \{m,r\}, m = \min B\left(\{s_1,\ldots,s_p\}\right), m \neq r
%\]
%where
%\[
%  \Phi^{*} = \Phi_{k-1}\left(\big\{ s_1, \ldots , s_{p-1}, \{z^{*},m\}, \{r,z^{**}\} \big\} \right)
%\]
%\[
%  (z^{*},z^{**}) = \argmin_{\substack{z^\prime \in [1,\ldots,m-1] \\\
%  z^{\prime\prime} \in [m+1, \min B\left(\{s_1,\ldots,s_{p-1}\}\right)-1]}}{
%    \mkern-28mu \mkern-18mu
%    \Phi_{k-1}\left(\big\{ s_1, \ldots , s_{p-1},
%    \{z^{\prime},m\}, \{r,z^{\prime\prime}\} \big\} \right)
%    + d(z^\prime,m) + d(z^{\prime\prime},r)
%  }
%\]
%\end{enumerate}
%\end{enumerate}
%
%\cite{example}
%

%\appendix
%\addcontentsline{toc}{chapter}{Appendices}
%\makeatletter
%\addtocontents{toc}{\let\protect\l@chapter\protect\l@section}
%\makeatother
%\chapter{First Appendix}
%\chapter{Second Appendix}

\clearpage
\begin{appendices}

\makeatletter
\addtocontents{toc}{\let\protect\l@chapter\protect\l@section}
\makeatother

%\section{Code Index}
%\lstlistoflistings%

\section{Compiler Support}
\label{app:compiler}
\input{sml-support.tex}

\section{Shared Library Interface}
\label{app:so}

\needspace{5\baselineskip}
\mylisting[
  caption={[FFI usage example]FFI usage example.},
  firstline=8,fontadjust,language=C,
  label=lst:so]{../src/rstsp/librstsp/test.c}

%\input{testapp.tex}

\section{References}
\printbibliography%

\end{appendices}

\end{document}

