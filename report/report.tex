%
% $Id$
% $Author$
% $Date$
% $Rev: 34 $
%

%\documentclass[titlepage,index=totoc,bibliography=totoc]{scrartcl}
\documentclass[index=totoc,bibliography=totoc]{scrartcl}
\KOMAoptions{fontsize=11pt}
%\KOMAoptions{BCOR=0.25mm}
%\usepackage[left=3.1cm, right=3.1cm]{geometry}

\usepackage{mathdesign}
\usepackage[no-math]{fontspec}
\defaultfontfeatures{Ligatures=TeX}
\setmainfont[Numbers=OldStyle]{Latin Modern Roman}
%\setmainfont[Numbers=OldStyle]{CMU Serif}
%\setmainfont[Numbers=OldStyle]{Gentium}
%\setmainfont[Numbers=OldStyle]{EB Garamond}
\setsansfont[Numbers=OldStyle]{CMU Sans Serif}
%\setsansfont{Droid Sans}
%\setmonofont{CMU Typewriter Text}
\setmonofont[Scale=0.9]{Droid Sans Mono}
%\setmonofont{DejaVu Sans Mono}
\newfontfamily\CodeFont[Scale=0.85]{DejaVu Sans Mono}
%\newfontfamily\CodeFont[Scale=0.85]{Consolas}
%\newfontfamily\CodeFont[Scale=0.85]{Anonymous Pro}

\usepackage{luatextra}

\usepackage[english,ngerman,russian]{babel}
\usepackage{csquotes}

% as of now, xindy is broken on my machine right
\usepackage{imakeidx}
\indexsetup{level=\chapter,toclevel=chapter}
\makeindex

\usepackage[backend=biber,style=alphabetic]{biblatex}
%\usepackage[fixlanguage]{babelbib}
\addbibresource{references.bib}
\usepackage[nottoc]{tocbibind}

\usepackage[basic]{complexity}
%\usepackage{xfrac}
%\usepackage{faktor}
\usepackage{amsmath}
%\usepackage{unicode-math}
\usepackage{amsfonts}
\usepackage{amssymb}

\usepackage{commath}
\usepackage{mathtools}

\usepackage{amsthm}
\usepackage{thmtools}
\usepackage{etoolbox}
\usepackage{changepage}

\usepackage{caption}
\usepackage{ragged2e}

\usepackage{graphicx}
%\usepackage[export]{adjustbox}
%\usepackage{epstopdf}
%\epstopdfDeclareGraphicsRule{.tif}{png}{.png}{convert #1 \OutputFile}
%\AppendGraphicsExtensions{.tif}
\usepackage{luamplib}
\usepackage{etoolbox}
\preto\mplibcode{\center\leavevmode}
\appto\endmplibcode{\endcenter}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{subfig}
\usepackage{sidecap}
\usepackage[bottom]{footmisc}

\usepackage{xcolor}
\definecolor{Gray}{gray}{0.9}
\definecolor{blue}{rgb}{0,0,0.3}
\definecolor{green}{rgb}{0,0.3,0}
\definecolor{codeblue}{rgb}{0,0,0.3}
\definecolor{codegreen}{rgb}{0,0.3,0}
\definecolor{codered}{rgb}{0.3,0,0}

\usepackage{listings}
\usepackage{needspace}
\lstset{%
  basicstyle=\CodeFont\footnotesize, %\footnotesize\ttfamily,
  frame=single, %line/leftline/single
  aboveskip=\topsep,
  belowskip=\topsep,
  breakatwhitespace=true,
  showstringspaces=false,
  breaklines=true,
  commentstyle=\itshape\color{codegreen},
  keywordstyle=\bfseries\color{codeblue},
  stringstyle=\color{codered},
  captionpos=t\/
}
\captionsetup[lstlisting]{font=footnotesize}
\newcommand{\mylisting}[2][]{%
  \lstinputlisting[caption={\texttt{\detokenize{#2}}},#1]{#2}%
}

%\usepackage{kantlipsum}
%\usepackage{blindtext}
\usepackage{marginnote}
\newcommand{\annotation}[1]{\marginpar{\small\itshape\color{green}#1}}

\usepackage{booktabs}
\usepackage{longtable}
\usepackage{color, colortbl}
\usepackage{multirow}
\usepackage{varwidth}
\usepackage{pgfplotstable}

\usepackage[title,page,titletoc]{appendix}
\newcommand*{\Appendixautorefname}{Appendix}

\usepackage{verbatim}
\usepackage{cprotect}

\usepackage{afterpage}
%\makeatletter
%\def\verbatim@font{\normalfont\itshape}
%\makeatother
\newcommand\blankpage{%
  \null%
  \thispagestyle{empty}%
  %\addtocounter{page}{-1}%
  \vspace*{\fill}
  \centering
  {\em {\small
  This page would have been intentionally left blank had we not chosen to
  \href{https://en.wikipedia.org/wiki/Recursion}{mention it}.
  }}%
  %\verbatiminput{|"/usr/games/fortune"}
  \vspace{\fill}%
  \newpage
}

\usepackage{abstract}

%\usepackage[toc]{multitoc}
\usepackage[subfigure]{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}

\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}
\newcommand*{\Cdot}{\raisebox{-0.30ex}{\scalebox{1.5}{$\cdot$}}}

\usepackage[pdfauthor={M. Deineko},
            pdfproducer={lualatex},
            pdfcreator={LaTeX},
            colorlinks=true,
            linkcolor=blue,
            urlcolor=blue,
            citecolor=blue,
            linktoc=section,
            unicode=true
            ]{hyperref}
\hypersetup{pdftitle=Two Exponential Neighbourhoods}
\usepackage[nameinlink]{cleveref}

\numberwithin{equation}{section}
\numberwithin{figure}{section}
\numberwithin{table}{section}

\declaretheorem[numberwithin=section,style=definition,name=Definition,refname={definition,definitions}]{define}
\declaretheorem[numberwithin=section,style=plain]{theorem}
\declaretheorem[sibling=theorem]{lemma}
\declaretheorem[sibling=theorem]{proposition}
\declaretheorem[sibling=theorem]{corollary}
\declaretheorem[numberwithin=section,style=remark]{remark}
%\BeforeBeginEnvironment{theorem}{\begin{adjustwidth}{1cm}{1cm}}
%\AfterEndEnvironment{theorem}{\endadjustwidth}
%\AfterEndEnvironment{define}{\noindent\ignorespaces}
%\makeatletter
%\def\@endtheorem{\endtrivlist}%
%\makeatother

\let\defstyle\itshape
%\def\defstyle{\itshape}

\begin{document}

\selectlanguage{english}

\title{Two Exponential Neighbourhoods}
\subtitle{Pyramidal and strongly balanced traveling salesman problem and related heuristics --- theory and implementation}
% FIXME: supervisor format ?
% FIXME: title pic / multitoc ?
% FIXME: twosided / book format ?
\input{authors.tex}
\date{\today}

% FIXME: titlepage / spacing ?
\maketitle

% FIXME: rewrite
\begin{abstract}
  Pyramidal tours constitute a well known polynomially solvable case of TSP\@.
  In this paper we present a first implementation of a related tours family,
  show extension of both solutions to local search heuristics
  and compare results thus obtained.
\end{abstract}

\thispagestyle{empty}

%\setlength{\cftbeforetoctitleskip}{-2em}
\tocloftpagestyle{empty}
%\afterpage{%
%  \null
%  \thispagestyle{empty}
%  \vspace{\fill}
%  \newpage
%}
\afterpage{\blankpage}
\clearpage
\tableofcontents

%\setlength{\parindent}{0cm}

\afterpage{\blankpage}
\clearpage

\dictum[Sherlock Holmes]{Nothing clears up a case so much as stating it to another person.}
\section{Introduction}

The {\defstyle traveling salesman problem (TSP)} can be colloquially stated as follows:
\index{TSP|see{Traveling Salesman Problem}}
\blockquote{%
  \index{Traveling Salesman Problem|(}
  A traveling merchant (or salesman) wishes to visit each city from a given
  list exactly once, starting from and returning to a select one of the cities
  given.  Assuming that distances between the cities are known and not
  subject to change, what would be the shortest route for him to take?
  \index{Traveling Salesman Problem|)}
}
This well studied problem in combinatorial optimization is known to be
NP-hard \cite{Karp72}; hence, one is interested in efficiently solvable
cases as well as useful heuristics, of which a good number exists.

In this paper we look at two exponential sets of feasible solutions over
which the TSP can be solved in polynomial time and extension of these to
iterative heuristics.  For this, we need to establish some basic
definitions first.

\subsection{Basic definitions and notation}

The TSP, as most mathematical problems, can be modeled in a number of often
equivalent or similar ways, depending on what aspects of the problem are
relevant to the task at hand --- which, for a problem as extensively studied
as this one, results in a great number of common terms which from author to
author can differ ever so slightly.

%Hence we need to establish a set of definitions which we shall try to keep
%precise enough to be able to convey this paper's content clearly,
%while also simple enough so as not to distract from it.
\annotation{Improve description of motivation/justification?}
In what follows, our goal is to establish consistent notation which can be easily
interpreted as a (functional) computer program.

\begin{define}[cities, paths and tours]
Given some $n \in \mathbb{N} \left(n \geq 2\right)$,
let \[\mathcal{N}_n \coloneqq \left\{1,\ldots,n\right\}.\]
We will refer to elements of $\mathcal{N}_n$ as {\defstyle cities}.
A non-empty tuple $\left(p_1,p_2,\ldots,p_m\right)$
of cities is called a {\defstyle path} (of {\defstyle walking length} $m-1$
{\defstyle over} $\mathcal{N}_n$);
it is called {\defstyle simple} if it contains distinct entries only, with
possible exception of its {\defstyle end points} $p_1$ and $p_m$, i.e. if
\[\left|\left\{p_1,p_2,\ldots,p_{m-1}\right\}\right| =
\left|\left\{p_2,p_3,\ldots,p_{m}\right\}\right| = m-1.\]  We shall refer to
a path of non-zero walking length with distinct end points as an {\defstyle open} path,
one with equal end points --- a {\defstyle closed} one, or a {\defstyle cycle}.
A path of walking length $1$ is also called an {\defstyle edge};
a simple cycle of walking length $n$ is called a {\defstyle tour}.
We then denote by
$\mathcal{P}_n \coloneqq \bigcup_{k \in \mathbb{N}}\mathcal{N}_n^k$
the set of all paths and by
$\mathcal{T}_n$ --- the set of all tours over $\mathcal{N}_n$.
\end{define}

We extend the common notion of path {\defstyle concatenation}
to perform a single reduction, as well as to allow for convenient notation for
images under said map defined as infix operator:
\begin{define}[path operations]
  Define {\defstyle path concatenation} to be the following map:
  \[
    \begin{split}
    \oplus \; : & \; {\left( \mathcal{P}_n \cup 2^{\mathcal{P}_n} \right)}^2 \to
                       \mathcal{P}_n \cup 2^{\mathcal{P}_n} \quad \text{(infix)},
    \\
    p \oplus q \coloneqq &
    \begin{cases}
      \left(p_1,\ldots,p_m,q_1,\ldots,q_k\right),
      & p = \left(p_1,\ldots,p_m\right) \in \mathcal{P}_n, \\
      & q = \left(q_1,\ldots,q_k\right) \in \mathcal{P}_n, \\
      & p_m \neq q_1;
      \\
      \left(p_1,\ldots,p_{m-1},q_1,\ldots,q_k\right),
      & p = \left(p_1,\ldots,p_m\right) \in \mathcal{P}_n, \\
      & q = \left(q_1,\ldots,q_k\right) \in \mathcal{P}_n, \\
      & p_m = q_1;
      \\
      \left\{p^\prime \oplus q \; \vert \; p^\prime \in p\right\},
      & p \notin \mathcal{P}_n, q \in \mathcal{P}_n;
      \\
      \left\{p \oplus q^\prime \; \vert \; q^\prime \in q\right\},
      & p \in \mathcal{P}_n, q \notin \mathcal{P}_n;
      \\
      \left\{p^\prime \oplus q^\prime \; \vert \; p^\prime \in p, q^\prime \in q\right\},
      & p \notin \mathcal{P}_n, q \notin \mathcal{P}_n,
    \end{cases}
    \end{split}
  \]
  {\defstyle path reversal} as
  \[
    \operatorname{rev} : \mathcal{P}_n \to \mathcal{P}_n, \;
    \left(p_1,p_2,\ldots,p_{m-1},p_m\right) \mapsto \left(p_m,p_{m-1},\ldots,p_2,p_1\right),
  \]
  and {\defstyle path closure} as
  \[
    \overline{\Cdot} : \mathcal{P}_n \to \mathcal{P}_n,
    \quad \left(p_1,\ldots,p_m\right) \mapsto
    \left(p_1,\ldots,p_m\right) \oplus \left(p_1\right),
  \]
  while also allowing for image notation:
  for $P \subseteq \mathcal{P}_n$, let
  \[
    \overline{P} \coloneqq \left\{\overline{p} \mid p \in P\right\}.
  \]
\end{define}

Note that path closure produces a bijection from the set of all simple open
paths of walking length $n-1$ over $\mathcal{N}_n$ onto $\mathcal{T}_n$.
Further, $\overline{\mathcal{T}_n} = \mathcal{T}_n$ holds true.

\begin{define}[costs and distances]
\label{def:cost}
  Given a $n \in \mathbb{N} \left(n \geq 2\right)$ and a matrix $C =
  \left(c_{i,j}\right) \in ~ \mathbb{R}^{n \times n}$, which we shall call
  {\defstyle cost} (or {\defstyle distance) matrix}, we will refer to its
  elements as {\defstyle distances} or {\defstyle weights}.
  Now let \[
    \omega_C: \mathcal{P}_n \to \mathbb{R}, \quad
    \left(p_1,p_2,\ldots,p_m\right) \mapsto \sum_{k=1}^{m-1} c_{p_k,p_{k+1}}.
  \]
  For a path $p$ over $\mathcal{N}_n$ we then call $\omega_C\left(p\right)$
  {\defstyle cost} of $p$.  An edge's cost is also called its {\defstyle weight}
  (which agrees with the definition above).
\end{define}

We would like to stress here that requiring tours to explicitly include a
city twice (as end points) allows us to employ same notion of cost for
paths and tours, which, in turn, will allow for convenient recursive
constructions later on.

\begin{define}[TSP]
\label{def:tsp}
  Given a $n \in \mathbb{N} \left(n \geq 2\right)$,
  $M \subseteq~\mathbb{R}^{n \times n}$ and
  $T \subseteq \mathcal{T}_n, \; T \neq \varnothing$,
  as well as a total order $L$ on $\mathcal{T}_n$,
  we define {\defstyle traveling salesman problem}
  ({\defstyle over $(M,T)$}, also {\defstyle TSP}) to be the map
\[
  \operatorname{tsp}_{L,M,T}: M \to T, \quad
  C \mapsto \min_L \operatorname{tsp^\ast}_{M,T}\left(C\right),
\]
and
\[
  \operatorname{tsp^\ast}_{M,T}: M \to 2^T, \quad
  C \mapsto \argmin_{\tau \in T} \omega_C\left(\tau\right) =
  \left({\omega_C\!}\restriction_T\right)^{-1}
  \left(\left\{\min \omega_C\left(T\right)\right\}\right).
\]
We call $n$ the TSP's {\defstyle dimension}.
If $M$ is a subset of symmetric matrices (over $\mathbb{R}$), the TSP is
called {\defstyle symmetric (sTSP)}, otherwise --- {\defstyle asymmetric (aTSP)}.
\end{define}

\begin{remark}
  Both $\operatorname{tsp^\ast}$ and $\operatorname{tsp}$ are well-defined maps:
  $1 \leq \left|T\right| < \infty$ holds, hence $\;\omega_C$ assumes a minimum
  value over $T$ and $\varnothing \notin \operatorname{tsp^\ast}_{M,T}\left(M\right)$.
\end{remark}

\begin{remark}
Frequently, the TSP is defined via a map which provides the sets $M$ and
$T$ for every dimension $n$.  We make no such requirement --- however, such
an extension is easily established from context, and throughout the rest of
this paper we will usually assume that some such dimension is given.

Whenever the sets $M,T$ in above definition are established elsewhere,
they are usually omitted from notation.  The pair $(M,T)$ is called a
{\defstyle class} or {\defstyle (special) case} of TSP.
\end{remark}

\begin{remark}
Often, the convention is to define TSP to be the symmetric version
\annotation{Reduction remark acceptable without reference?}
(aTSP can also be reduced to sTSP of twice the dimension).
We shall make no such assumption without a prior notice.
\end{remark}

\begin{remark}
It follows from \cref{def:cost,def:tsp} that
$\operatorname{tsp}_{M,T}^\ast\left(C\right) =
 \operatorname{tsp}_{M,T}^\ast\left(C + \lambda J\right)$
holds true for all $\lambda \in \mathbb{R}$ and $C \in M$,
where $J$ is matrix of ones (of suitable dimension).
Hence we can always assume
\[
  c_{i,j} \geq 0 \quad \forall i,j \in \mathcal{N}_n
\]
and shall do so henceforth.
\end{remark}

\begin{remark}
\label{rem:order}
\annotation{Choice of representative important in, say, ILS.}
  Cost equality naturally induces a partition of $\mathcal{T}_n$ (or its
  subset $T$ above).  Usually, we are not interested in all elements of
  $\operatorname{tsp^\ast}\left(C\right)$ or its representative given by a
  particular order $L$ (as produced by $\operatorname{tsp}_L\left(C\right)$)
  but rather in any such tour.  Hence we make do with the assumption that
  we may choose any order on $\mathcal{T}_n$ and treat $L$ as implicit argument
  to $\operatorname{tsp}$, omitting it from notation where possible ---
  in practice, it is usually given implicitly by construction.
\end{remark}

\begin{remark}
\annotation{Remove this.}
  Also not unusual (and useful in time complexity considerations) is a
  variation of TSP which returns the cost of optimal tour along with or
  instead of such a tour --- transition between these definitions is
  usually obvious.  While latter makes the distinction between
  $\operatorname{tsp}$ and $\operatorname{tsp^\ast}$ unnecessary and
  alleviates issues raised in \cref{rem:order}, it does not provide an
  obvious solution to the colloquial form of TSP, and ignoring said issues
  only conveniently moves them to particular implementation, refusing them
  proper formal treatment ab ovo.
\end{remark}

\subsection{Exponential neighbourhoods and local search}

Since the TSP in its general form is NP-hard, one is naturally interested
in efficiently solvable cases as well as good heuristics; this leads us to
following general definitions.

\begin{define}[(exponential) neighbourhood]
  A {\defstyle neighbourhood}
  ({\defstyle in $\mathcal{T}_n$} or {\defstyle over $\mathcal{N}_n$}) is a map
  \[
    F: \mathcal{T}_n \to 2^{\mathcal{T}_n}
    \quad \text{s.t.}\; \tau \in F\left(\tau\right) \ \forall \tau \in \mathcal{T}_n\;\footnote{%
      Not a common demand, this is sensible in context of (iterated) local search,
      and also makes $F\left(\tau\right)$ a neighbourhood of $\tau$
      according to discrete topology on $\mathcal{T}_n$.}.
  \]
  $F(\tau)$ is also called {\defstyle neighbourhood of} $\tau$.
  Once again, $n$ can be seen either as given dimension or implicit
  argument to $F$; a neighbourhood $F$ is called {\defstyle exponential} if
  \annotation{$\Omega$ or $\Theta$?}
  \[
    \left\vert F(\tau) \right\vert = \Theta(2^n) \qquad \forall \tau \in \mathcal{T}_n.
  \]
\end{define}

\begin{define}[local search]
  Given a neighbourhood $F$ in $\mathcal{T}_n$
  as well as $M \subseteq~\mathbb{R}^{n \times n}$ and $C \in M$,
  we define {\defstyle local search}
  ({\defstyle in} or {\defstyle over $F$}) to be the map
  \[
    l_C :
    \mathcal{T}_n \to \mathcal{T}_n, \quad
    \tau \mapsto \operatorname{tsp}_{M,F(\tau)}\left(C\right).
  \]
  $F$ is said to be {\defstyle polynomially solvable} if
  $l_{C^\prime}\!\in \P \ \forall C^\prime \in M$
  (where time complexity is measured in relation to $n$).
\end{define}

\begin{remark}
\label{rem:localappr}
  Note how for any tour $\tau$, local search defines a map on $M$ via
  $C^\prime \mapsto l_{C^\prime}\left(\tau\right)$, which can also be seen
  as approximation of $\operatorname{tsp}_{M,\mathcal{T}_n}$.
\end{remark}

\begin{remark}
\label{rem:nondecr}
\annotation{is ,,for any $C$'' necessary here?}
  For any tour $\tau$, with $\tau \in F\left(\tau\right)$ we also have
  \[
    \omega_C\left(l_C\left(\tau\right)\right) \leq \omega_C\left(\tau\right).
  \]
  %for all cost matrices $C$.
\end{remark}

Combining \cref{rem:localappr,rem:nondecr} naturally yields an iterative
improvement heuristic:

\begin{define}[ILS]
\label{def:ils}
  Given a local search function as above and a {\defstyle starting tour}
  $\tau^\ast$, we define {\defstyle iterative} or {\defstyle iterated local search}
  ({\defstyle ILS}) to be the map assigning to each $C \in M$ the
  fixed point of
  \[
    \tau \mapsto
    \begin{cases}
      \tau \quad & \text{if} \;
      \omega_C\left(l_C\left(\tau\right)\right) = \omega_C\left(\tau\right),
      \\
      l_C\left(\tau\right) & \text{otherwise}
    \end{cases}
  \]
  which is reached by iteration from $\tau^\ast$.
  We shall sometimes refer to such a fixed point as {\defstyle stale iteration}.
\end{define}

\begin{remark}
  In practice, termination conditions employed in ILS may vary and commonly
  include such parameters as number of iterations performed, time elapsed
  or some cost improvement metric.
\end{remark}

\annotation{Necessary?}
\begin{remark}
  There seems to exist no commonly accepted distinction between local
  search and iterated local search.  Often, the former is not required to
  solve the problem in $F\left(\tau\right)$ but only in some small subset
  of it, or to consist of multiple such improvement steps, which is
  referred to as {\defstyle anytime} heuristic.  Thus, depending on the
  definition of what constitutes a step, one can potentially be seen as
  special case of the other.
\end{remark}

\subsection{Tours and permutations}

Given the set $\mathcal{N}_n$ of $n$ cities, let $\mathcal{S}_n$ be the symmetric group (on $\mathcal{N}_n$).

\begin{define}[associated permutation]
  We define $\sigma_{\Cdot}$ (using argument-in-subscript notation) to be the map
  \[
      \sigma_{\Cdot} :
      \mathcal{T}_n \to \; \mathcal{S}_n, \quad
      \tau = \left(p_1, p_2, \ldots, p_n, p_1 \right)
      \mapsto
    \sigma_\tau \coloneqq
    \begin{pmatrix}
      1 & 2 & \cdots & n \\
      p_1 & p_2 & \cdots &  p_n
    \end{pmatrix},
  \]
  and, seeing how this constitutes a bijection, define $\pi$ to be its inverse,
  while letting $\sigma_\tau^{-1}$ denote permutation inverse to $\sigma_\tau$.
  %\[
  %  \pi & \coloneqq \left(\sigma_{\Cdot}\right)^{-1}.
  %\]
  We say then that $\tau$ and $\sigma_\tau$ are {\defstyle associated} with one another.
\end{define}

\begin{remark}
  We note here that function composition is default group operation on
  $\mathcal{S}_n$ and therefore can be omitted from notation where it is
  convenient and does not cause unnecessary ambiguity.
\end{remark}

The map $\pi$, being a bijection, conveniently provides a natural extension
of cost to $\mathcal{S}_n$ via $\omega_C \circ \pi$:
\begin{define}[cost of permutation]
  For a cost matrix $C$ of dimension $n$,
  we shall extend $\omega_C$ to $\mathcal{P}_n \cup \mathcal{S}_n$
  by setting, for any $\rho \in \mathcal{S}_n$,
  \[
    \omega_C\left(\rho\right) \coloneqq \omega_C\left(\pi\left(\rho\right)\right).
  \]
\end{define}

Similarly, we can use the map $\sigma_{\Cdot}$ for following convenient notation:
\begin{define}[action of $\mathcal{S}_n$]
\label{def:actions}
  For $\tau \in \mathcal{T}_n, \rho \in \mathcal{S}_n,
       C \in M \subseteq \mathbb{R}^{n \times n}, T \in 2^{\mathcal{T}_n}$,
  we define
  \begin{align*}
    \tau \rho & \coloneqq \sigma_\tau \rho, \\
    \rho \, \tau & \coloneqq \rho \, \sigma_\tau, \\
    \rho \, T & \coloneqq \pi\left(\left\{ \rho \, \sigma_\eta \mid \eta \in T \right\}\right), \\
    \rho \, C & \coloneqq \left(c_{\rho\left(i\right),\rho\left(j\right)}\right), \\
    \rho M & \coloneqq \left\{ \rho \, \widehat{C} \mid \widehat{C} \in M \right\}.
  \end{align*}
\end{define}

We can see that $\rho \, \tau$ is associated with the tour $\tau$ over
cities reordered by $\rho$, and if we consider $\tau \rho$ to be a
reordering of the tour $\tau$, following result becomes intuitively
agreeable:

\begin{proposition}
\label{prop:rotinv}
  For any permutation $\rho \in \left<\left(1 \; 2 \; \cdots \; n \right)\right>
  = \left\{{\left(1 \; 2 \; \cdots \; n \right)}^m \mid m \in \mathbb{Z} \right\}$,
  \[
    \omega_C\left(\tau\right) = \omega_C\left(\tau \rho\right)
  \]
  holds true for all $\tau \in \mathcal{T}_n$ and all $C \in \mathbb{R}^{n \times n}$.
\end{proposition}
\begin{proof}
  Consider following natural isomorphism between $\mathbb{Z}/n\mathbb{Z}$ and $\mathcal{N}_n$:
  for $i \in \mathbb{Z}$, let
  \[
    d\left(i\right) \coloneqq \left(\left(i-1\right)\operatorname{mod} n\right)+1.
  \]
  We have $d\left(\mathbb{Z}\right) = \mathcal{N}_n$,
  and $d\restriction_{\mathcal{N}_n} = \operatorname{id}_{\mathcal{N}_n}$
  is trivially a bijection (as is $\rho$); further,
  \begin{align}
    \label{eq:add}
    d\left(x+y\right) =
    d\left(d\left(x\right) + d\left(y\right)\right)
    \quad \forall x \in \mathbb{Z} \; \forall y \in \mathbb{Z},
  \end{align}
  and with $d\left(n+1\right) = 1$ we can now write the cost function from \cref{def:cost} as
  \begin{equation}
  \label{eq:cost}
    \omega_C\left(\tau\right) =
    \sum_{i=1}^n c_{\sigma_\tau\left(i\right),\sigma_\tau\left(d\left(i+1\right)\right)}.
  \end{equation}
  We also note that \exists $K \in \mathcal{N}_n$ s.t.\ 
  $\rho\left(i\right) = d\left(i+K\right) \; \forall i \in \mathcal{N}_n$,
  and, using \cref{eq:add}, obtain
  \begin{align}
    \label{eq:addadd}
    \begin{split}
    \rho \left(d\left(i+1\right)\right)
    & =
    d\left(d\left(i+1\right)+K\right) =
    d\left(d\left(i+1\right)+d\left(K\right)\right) =
    d\left(i+1+K\right) =
    \\
    & =
    d\left(d\left(i+K\right)+d\left(1\right)\right) =
    d\left(d\left(i+K\right)+1\right) =
    d\left(\rho\left(i\right)+1\right)
    \end{split}
  \end{align}
  for any city $i$.
  It now follows that
  \begin{align*}
    \omega_C\left(\tau \rho\right) =
    \omega_C\left(\pi\left(\sigma_\tau \circ \rho\right)\right)
    & \stackrel{\eqref{eq:cost}}{=}
    \sum_{i=1}^n c_{\sigma_\tau\left(\rho\left(i\right)\right),
                    \sigma_\tau\left(\rho\left(d\left(i+1\right)\right)\right)}
    =
    \\
    & \stackrel{\eqref{eq:addadd}}{=}
    \sum_{k=1}^n c_{\sigma_\tau\left(k\right),
                    \sigma_\tau\left(d\left(k+1\right)\right)}
    \stackrel{\eqref{eq:cost}}{=}
    \omega_C\left(\tau\right).
  \end{align*}
\end{proof}

\begin{remark}
  \annotation{Wording?}
  This shows, in particular, how resticting the tour set in the TSP to a
  fixed starting city does not necessarily signify a qualitative
  restriction of solutions set.
\end{remark}

We now want to establish a connection between permutations of cities,
reorderings of tours and solutions to the TSP.

\begin{lemma}
\label{lemma:ordermat}
  For any $\rho \in \mathcal{S}_n, C \in \mathbb{R}^{n \times n}, \tau \in \mathcal{T}_n$,
  \[
    \omega_C\left(\rho\,\tau\right) = \omega_{\rho\,C}\left(\tau\right)
  \]
  holds true.
\end{lemma}
\begin{proof}
  Borrowing definition of $d$ from the proof of \cref{prop:rotinv},
  and using \cref{eq:cost} along with \cref{def:actions}, we obtain
  \begin{align*}
    \omega_{\rho\,C}\left(\tau\right) =
    \sum_{i=1}^n c_{\rho\left(\sigma_\tau\left(i\right)\right),
                    \rho\left(\sigma_\tau\left(d\left(i+1\right)\right)\right)} =
    \omega_C\left(\rho \circ \sigma_\tau\right) =
    \omega_C\left(\rho\,\tau\right).
  \end{align*}
\end{proof}

\begin{corollary}[reordered TSP]
\label{cor:reorder}
  For any $\rho \in \mathcal{S}_n, C \in M \subseteq \mathbb{R}^{n \times n},
  \tau \in \mathcal{T}_n$,
  \annotation{,,Latter for any pair of compatible orderings $L, \rho L$'' or some such necessary?}
  \begin{align*}
  \begin{split}
    \operatorname{tsp}^\ast_{M,\rho T}\left(C\right)
    & =
    \rho \: \operatorname{tsp}^\ast_{\rho M,T}\left(\rho\,C\right),
    \\
    \operatorname{tsp}_{M,\rho T}\left(C\right)
    & =
    \pi\big( \rho \: \operatorname{tsp}_{\rho M,T}\left(\rho\,C\right) \big).
  \end{split}
  \end{align*}
  %% Latter equality holds for any two orderings of tours where one is image of the other under $\rho$.
  %% (which one exactly?)
\end{corollary}
\begin{proof}
  Using \cref{lemma:ordermat} and \cref{def:tsp}, we obtain
  \begin{align*}
    \begin{split}
    \operatorname{tsp}^\ast_{\left\{\rho\,C\right\},T}\left(\rho\,C\right)
    & =
    \argmin_{\tau \in T} \omega_{\rho\,C}\left(\tau\right) =
    \argmin_{\tau \in T} \omega_{C}\left(\rho\,\tau\right) =
    \\
    & =
    \rho^{-1} \: \argmin_{\rho\tau \in \rho T} \omega_{C}\left(\rho\,\tau\right) =
    \rho^{-1} \: \operatorname{tsp}^\ast_{\left\{C\right\},\rho T}\left(C\right),
    \end{split}
  \end{align*}
  from which the rest follows.
\end{proof}

\subsection{Tour sets as neighbourhoods}

Given a non-empty set of tours $T$, we can choose some (any) element
$\tau^\ast \in T$ and consider $T$ to be a set of permutations of
$\tau^\ast$ --- its action then defines a neighbourhood in $\mathcal{T}_n$:

\begin{define}[induced neighbourhood]
  \label{def:induced}
  Given a set of tours $T \subseteq \mathcal{T}_n$ and a tour $\tau^\ast \in T$,
  define $F_T$ to be the map
  \[
    F_T: \mathcal{T}_n \to 2^{\mathcal{T}_n}, \quad
    \tau \mapsto
    \pi \left(
      \left\{ \sigma_{\tau} \circ \sigma_{\tau^\ast}^{-1} \circ \sigma_{\tau^\prime}
              \mid \tau^{\prime} \in T\right\}
    \right)
    =
      \left(\sigma_{\tau} \circ \sigma_{\tau^\ast}^{-1}\right) T.
  \]
  We call $F_T$ {\defstyle neighbourhood induced by} $T$
  ({\defstyle centred at} or {\defstyle with centre} $\tau^\ast$).
\end{define}

\begin{figure}[bht]
  \centering
  \includegraphics[width=0.49\textwidth]{../plot/build/ext-1.mps}
  \caption{A non-empty set of tours $T$ induces a neighbourhood $F_T$.}
\end{figure}

\begin{remark}
  It is quickly verified that
  $\tau \in F_T\left(\tau\right) \; \forall \tau \in \mathcal{T}_n,$
  i.e.\ $F_T$ is in fact a neighbourhood according to our definition.
  We further have $F_T\left(\tau^\ast\right) = T$.
\end{remark}

\begin{remark}
  We deliberately omit the choice of centre from actual notation of induced
  neighbourhood, treating it as implicit parameter --- which is usually
  established along with the set $T$.
\end{remark}

\begin{remark}
  If we now can solve the TSP efficiently over a fixed set of tours $T$
  (for arbitrary cost matrices), choosing a $\tau^\ast \in T$ immediately
  allows us to construct local search over $F_T$ --- applying
  \cref{cor:reorder} to \cref{def:induced}, we arrive at
  \[
    l_C\left(\tau\right) =
    \pi\left(\rho\,\operatorname{tsp}_{\rho M,T}\left(\rho\, C\right)\right),
    \quad
    \text{where}\; \rho = \sigma_\tau \sigma_{\tau^\ast}^{-1},
  \]
  and choosing $\tau^\ast$ to be the starting tour in \cref{def:ils} then
  yields iterated local search.
  %
  % OUR CODE: see tspsearch/itersearch.sml
  %
  %   inv_order = \sigma_{\tau^\ast}^{-1}
  %   lookup t = \sigma_t \circ inv_order
  %   map x y = x o y for permutation y
  %
\end{remark}

\clearpage

\dictum[L. Peter Deutsch]{To iterate is human, to recurse divine.}
\section{Theory}

Dynamic programming is a fruitful approach to tackling many problems in
combinatorial optimization --- this specifically includes traveling
salesman problem and a number of its special cases.  Here we want to
present two exponential neighbourhoods which are polynomially solvable via
dynamic programming solutions.

While the first one --- {\defstyle pyramidal tours} --- can be considered
widely known, less so is its extension to a viable local search heuristic
we will present herein.  The second --- {\defstyle strongly balanced tours}
--- is somewhat more involved in its construction and so had yet to see an
implementation until now, which can be seen as essential motivation behind
this project.

\subsection{Pyramidal tours}

\annotation{Who was first?  BIBLIOGRAPHY!}
Pyramidal TSP was first described by (whom? \cite{bellman,gilmore}?)
and can be defined as follows:

\begin{define}[pyramidal TSP]
  A simple path
  \[
  \left( p_1, \ldots, p_k, q_1, \ldots, q_m \right)
  \; \text{s.t.} \;
  \begin{cases}
    p_i < p_{i+1} \; & \forall i \in \mathcal{N}_{k-1},\\
    q_j > q_{j+1} \; & \forall j \in \mathcal{N}_{m-1},
  \end{cases}
  \]
  is called {\defstyle pyramidal}.  We shall denote by
  $\operatorname{Pyr}_n$ the set of all pyramidal tours in $\mathcal{T}_n$,
  and call TSP restricted to $\operatorname{Pyr}_n$ {\defstyle pyramidal TSP}.
\end{define}
We note here that the set $\operatorname{Pyr}_n$
induces a neighbourhood in $\mathcal{T}_n$ with centre
$\left(1, 2, \ldots, n, 1\right)$.

\begin{figure}[bht]
  \centering
  \includegraphics[width=0.49\textwidth]{../plot/build/pyr-2.mps}
  \caption{%
    For a pyramidal tour $\tau$, connected plot of $\sigma_\tau$'s
    graph resembles a pyramid (here: $n = 5$, wraps horizontally 
    at $1$ for cosmetic reasons).
  }
\end{figure}

This definition of pyramidal tours, while explaining the name, does not
yet offer an obvious different solution to the corresponding optimization
problem.  To achieve that, first we observe that every pyramidal tour
necessarily takes the shape
\[
\left(1, p_1, \ldots, p_k, n, q_1, \ldots, q_m, 1 \right)
\; \text{with} \;
\begin{cases}
  p_i < p_{i+1} \; & \forall i \in \mathcal{N}_{k-1},\\
  q_j > q_{j+1} \; & \forall j \in \mathcal{N}_{m-1},
\end{cases}
\]
and then notice that for any city, we can choose it to be
either element of $\left\{p_1,\ldots,p_k\right\}$
or element of $\left\{q_1,\ldots,p_m\right\}$,
and once we made that that choice, the city in question has unique position in the tour.
This argument makes $\left|\operatorname{Pyr}_n\right| = \Theta\left(2^n\right)$
evident and following construction transparent:

\begin{proposition}[recursive structure of $\operatorname{Pyr}_n$]
\label{prop:pyrall}
  For cities $i,j$ in $\mathcal{N}_n$,
  let $V\left(i,j\right)$ denote the set of all pyramidal paths
  $\left(i,p_1,\ldots,p_m,j\right)$
  in $\mathcal{P}_n$
  s.t.\ $\left\{p_1,\ldots,p_m\right\} = \left\{k,\ldots,n\right\}$
  with $k = \max\left\{i,j\right\}+1$.  Then
  \begin{align}
    \label{eq:pyrall}
    V\left(i,j\right) & =
    \begin{cases}
      \left\{\left(i,j\right)\right\}, & n \in \left\{i,j\right\},
      \\
      \left(i\right) \oplus V\left(k,j\right)
      \;\bigcup\;
      V\left(i,k\right) \oplus \left(j\right)
      & \text{otherwise ($k$ as above)},
    \end{cases}
  \end{align}
  and $\operatorname{Pyr}_n = V\left(1,1\right)$.
\end{proposition}
\begin{proof}
  The second case in \cref{eq:pyrall} becomes apparent when,
  using preceding argument,
  we choose position for each city one at a time in increasing order.
  The rest follows directly from our definition of $V$.
\end{proof}

\begin{figure}[hbt]
  \centering
  \includegraphics[width=0.49\textwidth]{../plot/build/pyr-3.mps}
  \label{fig:pyrpart}
  \caption{$\operatorname{Pyr}_n$ constructed one city at a time.}
\end{figure}

This translates directly onto a dynamic programming solution to pyramidal TSP:
\begin{corollary}[dynamic programming solution to pyramidal TSP]
\label{cor:pyrdp}
  For a suitable tour-valued definition of $\argmin^\ast$, the recurrence relation
  \begin{align}
    \label{eq:pyrdp}
    \Phi_C\left(i,j\right) & \coloneqq
    \begin{cases}
      \left(i,j\right), & n \in \left\{i,j\right\}, \\
      %\displaystyle \adjustlimits \min_L \argmin_T \omega_C & \text{otherwise},
      {\displaystyle \argmin_T}^\ast \omega_C & \text{otherwise},
    \end{cases}
    \\
      \text{where}\;
      T & =
      \left\{
      \left(i\right) \oplus \Phi_C\left(k,j\right),
      \Phi_C\left(i,k\right) \oplus \left(j\right)
      \right\},
      k = \max\left\{i,j\right\}+1,
      \nonumber
  \end{align}
  produces, for arbitrary cost matrices, a well-defined map $\Phi_C$ on $\mathcal{N}_n^2$,
  and via
  \[
    \phi~:~C~\mapsto~\Phi_C\left(1,1\right)
  \]
  a map on $\mathbb{R}^{n \times n}$.
  For latter,
  \[
    \phi = \operatorname{TSP_{\mathbb{R}^{n \times n},\operatorname{Pyr}_n}}
  \]
  holds true.
\end{corollary}
\begin{proof}
  Borrowing defition of $V$ from \cref{prop:pyrall}, we first note that,
  per induction over \eqref{eq:pyrall}, $V\left(i,j\right)$ is never empty.

  If we now choose $\argmin^\ast$ to select from two equal cost tours in
  $T$ one deterministically and independently from $C$ (say, the first of
  the two options in definition of $T$ above), then this, per construction,
  produces a linear order on paths in $V\left(\mathcal{N}_n^2\right)$, and
  hence also on $\operatorname{Pyr}_n$.

  We then see per induction over \cref{eq:pyrall,eq:pyrdp} that for all
  cities $i,j$ and cost matrices $C$, $\Phi_C\left(i,j\right)$ is the
  smallest (according to said order) cost minimizing tour in $V\left(i,j\right)$,
  %\[
  %  \Phi_C\left(i,j\right) = \argmin^\ast \omega_C V\left(i,j\right)
  %\]
  from which the rest follows.
\end{proof}

Recurrence relation such as the one introduced above are well visualized
via so called {\defstyle recursion tree}~--- a directed graph in which
nodes correspond to different arguments to the relation, and edges
represent recursive dependence.  For pyramidal TSP, \cref{fig:pyrtrace}
shows such a graph.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.92\textwidth]{../plot/build/trace_apyr.pdf}
\caption{Pyramidal (a)TSP recursion tree along with values of $\Phi_C$
  from \cref{cor:pyrdp} for a sample cost matrix $C$ ($n=5$).}
\label{fig:pyrtrace}
\end{figure}

%\begin{figure}[htbp]
%\null\hfill%
%\subfloat[aTSP]{%
%  \includegraphics[width=0.62\textwidth]{../plot/build/trace_apyr.pdf}
%}\hfill\null
%\null\hfill%
%\subfloat[sTSP]{%
%  \includegraphics[width=0.36\textwidth]{../plot/build/trace_pyr.pdf}
%}\hfill\null
%\caption{Pyramidal TSP: recursion tree.}
%\label{fig:pyrtraces}
%\end{figure}

\annotation{TODO FROM HERE}

\subsection{Recursion and complexity}

While \cref{cor:pyrdp} offers a solution to the pyramidal TSP, the function
as it is presented in \cref{eq:pyrdp} does not yet necessarily translate
onto an efficient computer program.  For this,.

\begin{figure}[htbp]
\centering
\includegraphics[width=0.59\textwidth]{../plot/build/trace_pyr.pdf}
\caption{A trace of our implementation's pyramidal search graph traversal over $K_5$.}
\end{figure}

\subsection{Four point conditions and exponential neighbourhoods}

\annotation{Demidenko conditions: is a description necessary/interesting?}
While determining if a given TSP instance is pyramidal is NP-hard \cite{baki},
a number of polynomially testable classes which are pyramidally solvable exist \cite{baki,gilmore} ---
still, those are not widely common.

\subsection{Strongly balanced tours}

Another class of sTSP is the {\em Relaxed Supnick TSP} \/(RS-TSP), which is
obtained by restricting considered instances via a simple four-point
condition:
\[
  c_{ik} + c_{jl} \leq c_{il} + c_{jk} \quad \forall \; 1 \leq i < j < k < l \leq n,
\]
where $\left(c_{ij}\right)$ is the distance matrix.

While it has been shown that RS-TSP is NP-hard, an exponential subset of
said problem which is polynomially solvable has also been found.

\subsection{Strongly balanced tours and linear time conjecture}

It can subsequently be shown that the set of strongly balanced tours contains optimal solution
to TSP restricted to Relaxed Supnick matrices which additionaly satisfy
\[
  c_{il} + c_{jk} + c_{km} \geq c_{ik} + c_{jm} + c_{kl}
  \quad \forall i < j < k < l < m
\]
and that this condition can be checked in quadratic time.

If we further restrict this set by
\[
  c_{ji} + c_{kl} \leq c_{jl} + c_{ki} \quad \forall i<j, \; j+h \leq k < l
\]
for a given constant $h$, then we can show that the optimum can be found
amongst balanced tours for which number of paths of each element of $\mathcal T$
does not exceed $h/2 + 1$, and for such families size of ${\mathcal T}_n$ is bounded
by a constant for given $h$ \cite{fpneighb,fpclass}.

Number of unique node types, which presents upper bound for tree width, can
be seen in \autoref{tbl:nodeTypes}.  A breadth-first search implementation
could be used to naturally compute the tree width.

\annotation{Show how number of tours is $\Omega(2^n)$.}
Noting how the definition of strongly balanced tours naturally
yields a dynamic programming recursion, this results in a linear time
solution for the given exponential neighbourhood.

\setlength{\aboverulesep}{0pt}
\setlength{\belowrulesep}{0pt}
\renewcommand{\tabcolsep}{9pt}
\setlength{\extrarowheight}{1.1ex}
\newcolumntype{g}{>{\columncolor{Gray}}c}

\begin{table}[htpb]
\centering
    \mbox{%
      \pgfplotstabletypeset[
        col sep=space,
        std=-10:10,
        every head row/.style={output empty row},
        every head row/.style={%
          before row={\toprule},
          after row={\midrule}
        },
        display columns/0/.style={%
          column name={\bfseries Node size limit},
          column type={g}
        },
        display columns/1/.style={%
          column name={\bfseries Node types},
          column type={r}
        },
        display columns/2/.style={%
          column name={\bfseries Stable at depth},
          column type={g}
        },
        every last row/.style={after row=\bottomrule},
        %multicolumn names,
      ]{../plot/data/num\string_types.csv}%
    }
\caption{Number of node types encountered.}%
\label{tbl:nodeTypes}%
\end{table}

\begin{figure}[htbp]
\makebox[\textwidth][c]{%
  \includegraphics[width=1.21\textwidth]{../plot/build/trace_bal.pdf}
}
\caption{%
  A trace of our implementation's strongly balanced search graph traversal over $K_8$.  Here, maximum node size is 2.
}
\end{figure}

\subsection{Local search and flowers}

Pyramidal flower: \cite{belperm}.

\clearpage

\dictum[Donald Knuth]{Youâ€™re bound to be unhappy if you optimize everything.}
\section{Implementation}

\subsection{Key features}
\annotation{TODO}

Written in {\ttfamily Standard ML}.
Usable via SML REPL, standalone executable or shared library.
Tested under multiple software (see \autoref{app:compiler}) and OS/hardware platforms --
Linux (amd64) and Windows (x86) (MinGW-crosscompiled).

\annotation{Tradeoff illustration: provide LOC count?}
General dynamic programming results implementation via search graph traversal (simple depth-first search),
making a tradeoff between performance and extendibility.
BFS could be somewhat faster, but for our research dfs is enough.
Memoization via hash tables.

\annotation{Can we rename repo?}
This project's sources are available
\href{https://bitbucket.org/mad_hatter/rstsp/}{online}\footnote{\url{https://bitbucket.org/mad_hatter/rstsp/}}.

\subsection{Runtime behaviour}
\annotation{TODO}
\annotation{Describe \autoref{fig:benchRAND}.}

Clearly pronounced linear runtime for str.~balanced search, apparently heavy overhead penalty.
Pyramidal faster but str.~balanced eventually takes over.
See \autoref{fig:benchRAND}.
Memory usage not seriously measured, since bottleneck here is runtime.

\begin{figure}[htbp]
\null\hfill%
\subfloat[higher node sizes]{%
  \includegraphics[width=0.49\textwidth]{../plot/build/mlton_time_random_low.pdf}
}\hfill\null
\null\hfill%
\subfloat[medium node sizes]{%
  \includegraphics[width=0.49\textwidth]{../plot/build/mlton_time_random_fast.pdf}
}\hfill\null\\
\null\hfill%
\subfloat[low node sizes]{%
  \includegraphics[width=0.59\textwidth]{../plot/build/mlton_time_random_steady.pdf}
}\hfill\null\\
\null\hfill%
\subfloat[pyramidal vs str.~balanced/m3]{%
  \includegraphics[width=0.49\textwidth]{../plot/build/mlton_time_random_med.pdf}
}\hfill\null
\null\hfill%
\subfloat[pyramidal vs str.~balanced/m4]{%
  \includegraphics[width=0.49\textwidth]{../plot/build/mlton_time_random_hi.pdf}
}
\hfill\null
\caption{Single traversal running times (Linux 3.10.17 ({\ttfamily x86\_64}) @ i5-2520M).}
\label{fig:benchRAND}
\end{figure}

\subsection{Tour benchmarks}

\annotation{TODO}
Describe results, add Relaxed Supnick matrices benchmarks (!),
prettier (also, split) histograms?, plot iterations behavior? -- see \autoref{fig:benchTSPLIB}.

In what limited testing we have done, pyramidal still performs better.

For str.~balanced: adaptive search seems to perform better
than always choosing from $2n+1$ specific permutations.

\begin{figure}[htbp]
\null\hfill%
\subfloat[random --- tour length]{%
  \includegraphics[width=0.69\textwidth]{../plot/build/random_val.pdf}
}\hfill\null\\
\null\hfill%
\subfloat[tsplib \& vlsi --- tour quality]{%
  \includegraphics[width=0.69\textwidth]{../plot/build/tsplib_val.pdf}
}\hfill\null\\
\null\hfill%
\subfloat[tsplib \& vlsi --- time needed]{%
  \includegraphics[width=0.69\textwidth]{../plot/build/tsplib_time.pdf}
}\hfill\null
\caption{Benchmarks --- small instances.}
\label{fig:benchTSPLIB}
\end{figure}

\clearpage

\dictum[Arthur Bloch]{Enough research will tend to support your conclusions.}
\section{Conclusions}

\subsection{Results obtained}
\annotation{TODO}
First implementation of str.~balanced search.
Some benchmarks.
Preprocessing offers no gain.

\begin{figure}[htbp]
%\begin{wrapfigure}{r}{0.5\textwidth}
\centering
\includegraphics[width=0.54\textwidth]{./tsp.png}
\caption*{\captionsize Source: \small \url{https://xkcd.com/399/}.}
%\end{wrapfigure}
\end{figure}

\subsection{Areas for further research}
\annotation{TODO}

Are these heuristics better for aTSP\@?
Untested: other metrics or higher dimensions, dedicated implementations' performance.
Further heuristics combinations.
Branch cutting.
Different permutations set for str.~balanced tours?

\subsection{Dynamic programming algorithms and concurrency}
\annotation{TODO}

Dedicated implementations (pyramidal: bottom up easy) fast, but not always feasible (str.~balanced: machine-generated).
Naive concurrency (see the {\ttfamily experimental} code) not easily applicable in general case (dense search tree).
Potentially fruitful approaches: tuple spaces, message passing languages, etc
(PolyML/Linda?, manticore, jocaml, mythryl, aliceml, clojure/clotilde, scala/akka, $\ldots$).

%% lualatex+metapost demo:
%\begin{figure}[htbp]
%\centering%
%\begin{mplibcode}
%  beginfig(0)
%    pair p[];
%    p1 = (0,0); p2 = (100,0); p3 = (200,0); p4 = (300,0); p5 = (400,0);
%    pair c[];
%    c1 = (50,20); c2 = (210,30); c3 = (250,-10); c4 = (100,-20);
%    path a;
%    a = p1 .. controls c1 ..
%        p2 .. controls c2 ..
%        p4 ..
%        p5 .. controls c3 ..
%        p3 ..  controls c4 ..
%        cycle ;
%    for i = 1 upto length a:
%      dotlabel.top(decimal i, p[i]);
%      drawarrow subpath (i-1,i) of a withcolor 0.2;
%    endfor
%  endfig;
%\end{mplibcode}
%\ 
%\caption{A pyramidal tour over $K_5$.}
%\end{figure}

%\input{problem1.tex}

%\appendix
%\addcontentsline{toc}{chapter}{Appendices}
%\makeatletter
%\addtocontents{toc}{\let\protect\l@chapter\protect\l@section}
%\makeatother
%\chapter{First Appendix}
%\chapter{Second Appendix}

\clearpage
\begin{appendices}

\makeatletter
\addtocontents{toc}{\let\protect\l@chapter\protect\l@section}
\makeatother

%\section{Code Index}
%\lstlistoflistings%

\section{Shared Library Interface}
\label{app:so}

\needspace{5\baselineskip}
\mylisting[
  caption={[FFI usage example]FFI usage example.},
  firstline=8,fontadjust,language=C,
  label=lst:so]{../src/rstsp/librstsp/test.c}

\section{Sample REPL Session}

%\input{testapp.tex}

\section{Compiler Support}
\label{app:compiler}
\input{sml-support.tex}

\end{appendices}

%\printindex
\printbibliography%

\end{document}

