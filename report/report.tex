%
% $Id$
% $Author$
% $Date$
% $Rev: 34 $
%

%\documentclass[titlepage,index=totoc,bibliography=totoc]{scrartcl}
\documentclass[index=totoc,bibliography=totoc]{scrartcl}
\KOMAoptions{fontsize=11pt}
%\KOMAoptions{BCOR=0.25mm}
%\usepackage[left=3.1cm, right=3.1cm]{geometry}

\usepackage{mathdesign}
\usepackage[no-math]{fontspec}
\defaultfontfeatures{Ligatures=TeX}
\setmainfont[Numbers=OldStyle]{Latin Modern Roman}
%\setmainfont[Numbers=OldStyle]{CMU Serif}
%\setmainfont[Numbers=OldStyle]{Gentium}
%\setmainfont[Numbers=OldStyle]{EB Garamond}
\setsansfont[Numbers=OldStyle]{CMU Sans Serif}
%\setsansfont{Droid Sans}
%\setmonofont{CMU Typewriter Text}
\setmonofont[Scale=0.9]{Droid Sans Mono}
%\setmonofont{DejaVu Sans Mono}
\newfontfamily\CodeFont[Scale=0.85]{DejaVu Sans Mono}
%\newfontfamily\CodeFont[Scale=0.85]{Consolas}
%\newfontfamily\CodeFont[Scale=0.85]{Anonymous Pro}

\usepackage{luatextra}

\usepackage[english,ngerman,russian]{babel}
\usepackage{csquotes}

% as of now, xindy is broken on my machine right
\usepackage{imakeidx}
\indexsetup{level=\chapter,toclevel=chapter}
\makeindex

\usepackage[backend=biber,style=alphabetic]{biblatex}
%\usepackage[fixlanguage]{babelbib}
\addbibresource{references.bib}
\usepackage[nottoc]{tocbibind}

\usepackage[basic]{complexity}
%\usepackage{xfrac}
%\usepackage{faktor}
\usepackage{amsmath}
%\usepackage{unicode-math}
\usepackage{amsfonts}
\usepackage{amssymb}

\usepackage{commath}
\usepackage{mathtools}

\usepackage{amsthm}
\usepackage{thmtools}
\usepackage{etoolbox}
\usepackage{changepage}

\usepackage{caption}
\usepackage{ragged2e}

\usepackage{graphicx}
%\usepackage[export]{adjustbox}
%\usepackage{epstopdf}
%\epstopdfDeclareGraphicsRule{.tif}{png}{.png}{convert #1 \OutputFile}
%\AppendGraphicsExtensions{.tif}
\usepackage{luamplib}
\usepackage{etoolbox}
\preto\mplibcode{\center\leavevmode}
\appto\endmplibcode{\endcenter}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{subfig}
\usepackage{sidecap}
\usepackage[bottom]{footmisc}
\usepackage{enumerate}

\usepackage{xcolor}
\definecolor{Gray}{gray}{0.9}
\definecolor{blue}{rgb}{0,0,0.3}
\definecolor{green}{rgb}{0,0.3,0}
\definecolor{codeblue}{rgb}{0,0,0.3}
\definecolor{codegreen}{rgb}{0,0.3,0}
\definecolor{codered}{rgb}{0.3,0,0}

\usepackage{listings}
\usepackage{needspace}
\lstset{%
  basicstyle=\CodeFont\footnotesize, %\footnotesize\ttfamily,
  frame=single, %line/leftline/single
  aboveskip=\topsep,
  belowskip=\topsep,
  breakatwhitespace=true,
  showstringspaces=false,
  breaklines=true,
  commentstyle=\itshape\color{codegreen},
  keywordstyle=\bfseries\color{codeblue},
  stringstyle=\color{codered},
  captionpos=t\/
}
\captionsetup[lstlisting]{font=footnotesize}
\newcommand{\mylisting}[2][]{%
  \lstinputlisting[caption={\texttt{\detokenize{#2}}},#1]{#2}%
}

%\usepackage{kantlipsum}
%\usepackage{blindtext}
\usepackage{marginnote}
\newcommand{\annotation}[1]{\marginpar{\small\itshape\color{green}#1}}

\usepackage{booktabs}
\usepackage{longtable}
\usepackage{color, colortbl}
\usepackage{multirow}
\usepackage{varwidth}
\usepackage{pgfplotstable}

\usepackage[title,page,titletoc]{appendix}
\newcommand*{\Appendixautorefname}{Appendix}

\usepackage{verbatim}
\usepackage{cprotect}

\usepackage{afterpage}
%\makeatletter
%\def\verbatim@font{\normalfont\itshape}
%\makeatother
\newcommand\blankpage{%
  \null%
  \thispagestyle{empty}%
  %\addtocounter{page}{-1}%
  \vspace*{\fill}
  \centering
  {\em {\small
  This page would have been intentionally left blank had we not chosen to
  \href{https://en.wikipedia.org/wiki/Recursion}{mention it}.
  }}%
  %\verbatiminput{|"/usr/games/fortune"}
  \vspace{\fill}%
  \newpage
}

\usepackage{abstract}

%\usepackage[toc]{multitoc}
\usepackage[subfigure]{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}

\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}
\newcommand*{\Cdot}{\raisebox{-0.30ex}{\scalebox{1.5}{$\cdot$}}}

\usepackage[pdfauthor={M. Deineko},
            pdfproducer={lualatex},
            pdfcreator={LaTeX},
            colorlinks=true,
            linkcolor=blue,
            urlcolor=blue,
            citecolor=blue,
            linktoc=section,
            unicode=true
            ]{hyperref}
\hypersetup{pdftitle=Two Exponential Neighbourhoods}
\usepackage[nameinlink]{cleveref}

\numberwithin{equation}{section}
\numberwithin{figure}{section}
\numberwithin{table}{section}

\declaretheorem[numberwithin=section,style=definition,name=Definition,refname={definition,definitions}]{define}
\declaretheorem[numberwithin=section,style=plain]{theorem}
\declaretheorem[sibling=theorem]{lemma}
\declaretheorem[sibling=theorem]{proposition}
\declaretheorem[sibling=theorem]{corollary}
\declaretheorem[numberwithin=section,style=remark]{remark}
\declaretheorem[numberwithin=section,style=exstyle]{example}
%\BeforeBeginEnvironment{theorem}{\begin{adjustwidth}{1cm}{1cm}}
%\AfterEndEnvironment{theorem}{\endadjustwidth}
%\AfterEndEnvironment{define}{\noindent\ignorespaces}
%\makeatletter
%\def\@endtheorem{\endtrivlist}%
%\makeatother

\let\defstyle\itshape
%\def\defstyle{\itshape}

\begin{document}

\selectlanguage{english}

\title{Two Exponential Neighbourhoods}
\subtitle{Pyramidal and strongly balanced traveling salesman problem and related heuristics --- theory and implementation}
% FIXME: supervisor format ?
% FIXME: title pic / multitoc ?
% FIXME: twosided / book format ?
\input{authors.tex}
\date{\today}

% FIXME: titlepage / spacing ?
\maketitle

% FIXME: rewrite
\begin{abstract}
  Pyramidal tours constitute a well known polynomially solvable case of TSP\@.
  In this paper we present a first implementation of a related tours family,
  show extension of both solutions to local search heuristics
  and compare results thus obtained.
\end{abstract}

\thispagestyle{empty}

%\setlength{\cftbeforetoctitleskip}{-2em}
\tocloftpagestyle{empty}
%\afterpage{%
%  \null
%  \thispagestyle{empty}
%  \vspace{\fill}
%  \newpage
%}
\afterpage{\blankpage}
\clearpage
\tableofcontents

%\setlength{\parindent}{0cm}

\afterpage{\blankpage}
\clearpage

\dictum[Sherlock Holmes]{Nothing clears up a case so much as stating it to another person.}
\section{Introduction}

The {\defstyle traveling salesman problem (TSP)} can be colloquially stated as follows:
\index{TSP|see{Traveling Salesman Problem}}
\blockquote{%
  \index{Traveling Salesman Problem|(}
  A traveling merchant (or salesman) wishes to visit each city from a given
  list exactly once, starting from and returning to a select one of the cities
  given.  Assuming that distances between the cities are known and not
  subject to change, what would be the shortest route for him to take?
  \index{Traveling Salesman Problem|)}
}
This well studied problem in combinatorial optimization is known to be
NP-hard \cite{Karp72}; hence, one is interested in efficiently solvable
cases as well as useful heuristics, of which a good number exists.

In this paper we look at two exponential sets of feasible solutions over
which the TSP can be solved in polynomial time and extension of these to
iterative heuristics.  For this, we need to establish some basic
definitions first.

\subsection{Basic definitions and notation}

The TSP, as most mathematical problems, can be modeled in a number of often
equivalent or similar ways, depending on what aspects of the problem are
relevant to the task at hand --- which, for a problem as extensively studied
as this one, results in a great number of common terms which from author to
author can differ ever so slightly.

\annotation{Description/motivation: TODO throughout document + abstract}
In what follows, our goal is to establish notation which can be easily
interpreted as a (functional) computer program and thus help illustrate
the internals of our code.

\begin{define}[cities, paths and tours]
Given some $n \in \mathbb{N} \left(n \geq 2\right)$,
let \[\mathcal{N}_n \coloneqq \left\{1,\ldots,n\right\}.\]
We will refer to elements of $\mathcal{N}_n$ as {\defstyle cities}.
A non-empty tuple $\left(p_1,p_2,\ldots,p_m\right)$
of cities is called a {\defstyle path} (of {\defstyle walking length} $m-1$
{\defstyle over} $\mathcal{N}_n$);
it is called {\defstyle simple} if it contains distinct entries only, with
possible exception of its {\defstyle end points} $p_1$ and $p_m$, i.e. if
\[\left|\left\{p_1,p_2,\ldots,p_{m-1}\right\}\right| =
\left|\left\{p_2,p_3,\ldots,p_{m}\right\}\right| = m-1.\]  We shall refer to
a path of non-zero walking length with distinct end points as an {\defstyle open} path,
one with equal end points --- a {\defstyle closed} one, or a {\defstyle cycle}.
A path of walking length $1$ is also called an {\defstyle edge};
a simple cycle of walking length $n$ is called a {\defstyle tour}.
We then denote by
$\mathcal{P}_n \coloneqq \bigcup_{k \in \mathbb{N}}\mathcal{N}_n^k$
the set of all paths and by
$\mathcal{T}_n$ --- the set of all tours over $\mathcal{N}_n$.
\end{define}

We extend the common notion of path {\defstyle concatenation}
to perform a single reduction, as well as to allow for convenient notation for
images under said map defined as infix operator:
\begin{define}[path operations]
  Define {\defstyle path concatenation} to be the following map:
  \[
    \begin{split}
    \oplus \; : & \; {\left( \mathcal{P}_n \cup 2^{\mathcal{P}_n} \right)}^2 \to
                       \mathcal{P}_n \cup 2^{\mathcal{P}_n} \quad \text{(infix)},
    \\
    p \oplus q \coloneqq &
    \begin{cases}
      \left(p_1,\ldots,p_m,q_1,\ldots,q_k\right),
      & p = \left(p_1,\ldots,p_m\right) \in \mathcal{P}_n, \\
      & q = \left(q_1,\ldots,q_k\right) \in \mathcal{P}_n, \\
      & p_m \neq q_1;
      \\
      \left(p_1,\ldots,p_{m-1},q_1,\ldots,q_k\right),
      & p = \left(p_1,\ldots,p_m\right) \in \mathcal{P}_n, \\
      & q = \left(q_1,\ldots,q_k\right) \in \mathcal{P}_n, \\
      & p_m = q_1;
      \\
      \left\{p^\prime \oplus q \; \vert \; p^\prime \in p\right\},
      & p \notin \mathcal{P}_n, q \in \mathcal{P}_n;
      \\
      \left\{p \oplus q^\prime \; \vert \; q^\prime \in q\right\},
      & p \in \mathcal{P}_n, q \notin \mathcal{P}_n;
      \\
      \left\{p^\prime \oplus q^\prime \; \vert \; p^\prime \in p, q^\prime \in q\right\},
      & p \notin \mathcal{P}_n, q \notin \mathcal{P}_n,
    \end{cases}
    \end{split}
  \]
  {\defstyle path reversal} as
  \[
    \operatorname{rev} : \mathcal{P}_n \to \mathcal{P}_n, \;
    \left(p_1,p_2,\ldots,p_{m-1},p_m\right) \mapsto \left(p_m,p_{m-1},\ldots,p_2,p_1\right),
  \]
  and {\defstyle path closure} as
  \[
    \overline{\Cdot} : \mathcal{P}_n \to \mathcal{P}_n,
    \quad \left(p_1,\ldots,p_m\right) \mapsto
    \left(p_1,\ldots,p_m\right) \oplus \left(p_1\right),
  \]
  while also allowing for image notation:
  for $P \subseteq \mathcal{P}_n$, let
  \[
    \overline{P} \coloneqq \left\{\overline{p} \mid p \in P\right\}.
  \]
  We choose the concatenation operator to take precedence over set union.
\end{define}

\begin{example}
  With above definition, following holds for paths over $\mathcal{P}_n$ (for $n \geq 3$):
  \begin{align*}
    (1,2) \oplus (3,2) & = (1,2,3,2),
    \\
    (3,1) \oplus (1,1) & = (3,1,1),
    \\
    \left\{(2),(1)\right\} \oplus (1) & = \left\{(2,1),(1)\right\},
    \\
    \left\{(1)\right\} \oplus \left\{(1),(2)\right\} \cup \left\{(3)\right\} & = \left\{(1),(1,2),(3)\right\}.
  \end{align*}
\end{example}

\begin{remark}
Also note that path closure produces a bijection from the set of all simple open
paths of walking length $n-1$ over $\mathcal{N}_n$ onto $\mathcal{T}_n$.
Further, $\overline{\mathcal{T}_n} = \mathcal{T}_n$ holds true.
\end{remark}

\begin{define}[costs and distances]
\label{def:cost}
  Given a $n \in \mathbb{N} \left(n \geq 2\right)$ and a matrix $C =
  \left(c_{i,j}\right) \in ~ \mathbb{R}^{n \times n}$, which we shall call
  {\defstyle cost} (or {\defstyle distance) matrix}, we will refer to its
  elements as {\defstyle distances} or {\defstyle weights}.
  Now let \[
    \omega_C: \mathcal{P}_n \to \mathbb{R}, \quad
    \left(p_1,p_2,\ldots,p_m\right) \mapsto \sum_{k=1}^{m-1} c_{p_k,p_{k+1}}.
  \]
  For a path $p$ over $\mathcal{N}_n$ we then call $\omega_C\left(p\right)$
  {\defstyle cost} of $p$.  An edge's cost is also called its {\defstyle weight}
  (which agrees with the definition above).
\end{define}

We would like to stress here that requiring tours to explicitly include a
city twice (as end points) allows us to employ same notion of cost for
paths and tours, which, in turn, will allow for convenient recursive
constructions later on.

\begin{define}[TSP]
\label{def:tsp}
  Given a $n \in \mathbb{N} \left(n \geq 2\right)$,
  $M \subseteq~\mathbb{R}^{n \times n}$ and
  $T \subseteq \mathcal{T}_n, \; T \neq \varnothing$,
  as well as a total order $L$ on $\mathcal{T}_n$,
  we define {\defstyle traveling salesman problem}
  ({\defstyle over $(M,T)$}, also {\defstyle TSP}) to be the map
\[
  \operatorname{tsp}_{L,M,T}: M \to T, \quad
  C \mapsto \min_L \operatorname{tsp^\ast}_{M,T}\left(C\right),
\]
and
\[
  \operatorname{tsp^\ast}_{M,T}: M \to 2^T, \quad
  C \mapsto \argmin_{\tau \in T} \omega_C\left(\tau\right) =
  \left({\omega_C\!}\restriction_T\right)^{-1}
  \left(\left\{\min \omega_C\left(T\right)\right\}\right).
\]
We call $n$ the TSP's {\defstyle dimension}.
If $M$ is a subset of symmetric matrices (over $\mathbb{R}$), the TSP is
called {\defstyle symmetric (sTSP)}, otherwise --- {\defstyle asymmetric (aTSP)}.
\end{define}

\begin{remark}
  Both $\operatorname{tsp^\ast}$ and $\operatorname{tsp}$ are well-defined maps:
  $1 \leq \left|T\right| < \infty$ holds, hence $\;\omega_C$ assumes a minimum
  value over $T$ and $\varnothing \notin \operatorname{tsp^\ast}_{M,T}\left(M\right)$.
\end{remark}

\begin{remark}
Frequently, the TSP is defined via a map which provides the sets $M$ and
$T$ for every dimension $n$.  We make no such requirement --- however, such
an extension is easily established from context, and throughout the rest of
this paper we will usually assume that some such dimension is given.
Further, whenever the sets $M,T$ in above definition are established elsewhere,
they are usually omitted from notation.  The pair $(M,T)$ is called a
{\defstyle class} or {\defstyle (special) case} of TSP.
\end{remark}

\begin{remark}
  Also not unusual (and useful in time complexity considerations) is a
  variation of TSP which returns the cost of optimal tour along with
  such a tour --- transition between these definitions is usually obvious.
\end{remark}

\begin{remark}
Often, the convention is to define TSP to be the symmetric version
--- we shall make no such assumption without a prior notice.
On the other hand, following convention is useful:
observe how it follows from \cref{def:cost,def:tsp} that
$\operatorname{tsp}_{M,T}^\ast\left(C\right) ~ = ~
 \operatorname{tsp}_{M,T}^\ast\left(C + \lambda J\right)$
for all $\lambda \in \mathbb{R}$ and $C \in M$,
where $J$ is matrix of ones (of suitable dimension).
Hence we can always assume
\[
  c_{i,j} \geq 0 \quad \forall i,j \in \mathcal{N}_n
\]
and shall do so henceforth.
\end{remark}

\begin{remark}
\label{rem:order}
  Cost equality naturally induces a partition of $\mathcal{T}_n$ (or its
  subset $T$ above).  We are not always interested in all elements of
  $\operatorname{tsp^\ast}\left(C\right)$ or its representative given by a
  particular order $L$ (as produced by $\operatorname{tsp}_L\left(C\right)$)
  but rather in any such tour.
  We hence treat $L$ as implicit argument
  to $\operatorname{tsp}$, omitting it from notation where possible ---
  in practice, it is often given implicitly by construction, or may depend
  on even more arguments (such as some probability distribution) ---
  still, this choice of representative is something we need to be aware of
  throughout, as it propagates to any construct using $\operatorname{tsp}$ ---
  such as iterative methods presented herein.
\end{remark}

\subsection{Exponential neighbourhoods and local search}

Since the TSP in its general form is NP-hard, one is naturally interested
in efficiently solvable cases as well as good heuristics; this leads us to
following general definitions.

\begin{define}[(exponential) neighbourhood]
  A {\defstyle neighbourhood}
  ({\defstyle in $\mathcal{T}_n$} or {\defstyle over $\mathcal{N}_n$}) is a map
  \[
    F: \mathcal{T}_n \to 2^{\mathcal{T}_n}
    \quad \text{s.t.}\; \tau \in F\left(\tau\right) \ \forall \tau \in \mathcal{T}_n\;
    %\footnote{%
    %  Not a common demand, this is sensible in context of (iterated) local search,
    %  and also makes $F\left(\tau\right)$ a neighbourhood of $\tau$
    %  according to discrete topology on $\mathcal{T}_n$.}.
  \]
  $F(\tau)$ is also called {\defstyle neighbourhood of} $\tau$.
  Once again, $n$ can be seen either as given dimension or implicit
  argument to $F$; a neighbourhood $F$ is called {\defstyle exponential} if
  \annotation{$\Omega$ or $\Theta$?}
  \[
    \left\vert F(\tau) \right\vert = \Theta(2^n) \qquad \forall \tau \in \mathcal{T}_n.
  \]
\end{define}

\begin{define}[local search]
  Given a neighbourhood $F$ in $\mathcal{T}_n$
  as well as $M \subseteq~\mathbb{R}^{n \times n}$ and $C \in M$,
  we define {\defstyle local search}
  ({\defstyle in} or {\defstyle over $F$}) to be the map
  \[
    l_C :
    \mathcal{T}_n \to \mathcal{T}_n, \quad
    \tau \mapsto \operatorname{tsp}_{M,F(\tau)}\left(C\right).
  \]
  $F$ (as well as $l_C$) is said to be {\defstyle polynomially solvable} if
  $l_{C^\prime}\!\in \P \ \forall C^\prime \in M$
  (where time complexity is measured in relation to $n$).
\end{define}

\begin{remark}
  Not a universally common requirement, our reason to demand that
  $F\left(\tau\right)$ include $\tau$ per definition
  is to guarantee that for any tour $\tau$ and any cost matrix $C$,
  \[
    \omega_C\left(l_C\left(\tau\right)\right) \leq \omega_C\left(\tau\right).
  \]
\end{remark}

Also note how for any tour $\tau$ local search defines a map on $M$ via
$C^\prime \mapsto l_{C^\prime}\left(\tau\right)$, which can also be seen as
approximation of $\operatorname{tsp}_{M,\mathcal{T}_n}$.  This naturally
yields an iterative improvement heuristic:

\begin{define}[ILS]
\label{def:ils}
  Given a local search function as above and a {\defstyle starting tour}
  $\tau^\ast$, we define {\defstyle iterative} or {\defstyle iterated local search}
  ({\defstyle ILS}) to be the map assigning to each $C \in M$ the
  fixed point of
  \[
    \tau \mapsto
    \begin{cases}
      \tau \quad & \text{if} \;
      \omega_C\left(l_C\left(\tau\right)\right) = \omega_C\left(\tau\right),
      \\
      l_C\left(\tau\right) & \text{otherwise}
    \end{cases}
  \]
  which is reached by iteration from $\tau^\ast$.
  We shall sometimes refer to such a fixed point as {\defstyle stale iteration}.
\end{define}

In practice, termination conditions employed in ILS may vary and commonly
include such parameters as number of iterations performed, time elapsed
or some cost improvement metric.

\annotation{Necessary?}
\begin{remark}
  There seems to exist no commonly accepted distinction between local
  search and iterated local search.  Often, the former is not required to
  solve the problem in $F\left(\tau\right)$ but only in some small subset
  of it, or to consist of multiple such improvement steps, which is
  referred to as {\defstyle anytime} heuristic.  Thus, depending on the
  definition of what constitutes a step, one can potentially be seen as
  special case of the other.
\end{remark}

\subsection{Tours and permutations}

Given the set $\mathcal{N}_n$ of $n$ cities, let $\mathcal{S}_n$ be the symmetric group (on $\mathcal{N}_n$).

\begin{define}[associated permutation]
  We define $\sigma_{\Cdot}$ (using argument-in-subscript notation) to be the map
  \[
      \sigma_{\Cdot} :
      \mathcal{T}_n \to \; \mathcal{S}_n, \quad
      \tau = \left(p_1, p_2, \ldots, p_n, p_1 \right)
      \mapsto
    \sigma_\tau \coloneqq
    \begin{pmatrix}
      1 & 2 & \cdots & n \\
      p_1 & p_2 & \cdots &  p_n
    \end{pmatrix},
  \]
  and, seeing how this constitutes a bijection, define $\pi$ to be its inverse,
  while letting $\sigma_\tau^{-1}$ denote permutation inverse to $\sigma_\tau$.
  %\[
  %  \pi & \coloneqq \left(\sigma_{\Cdot}\right)^{-1}.
  %\]
  We say then that $\tau$ and $\sigma_\tau$ are {\defstyle associated} with one another.
\end{define}

\begin{remark}
  We note here that function composition is default group operation on
  $\mathcal{S}_n$ and therefore can be omitted from notation where it is
  convenient and does not cause unnecessary ambiguity.
\end{remark}

The map $\pi$, being a bijection, conveniently provides a natural extension
of cost to $\mathcal{S}_n$ via $\omega_C \circ \pi$:
\begin{define}[cost of permutation]
  For a cost matrix $C$ of dimension $n$,
  we shall extend $\omega_C$ to $\mathcal{P}_n \cup \mathcal{S}_n$
  by setting, for any $\rho \in \mathcal{S}_n$,
  \[
    \omega_C\left(\rho\right) \coloneqq \omega_C\left(\pi\left(\rho\right)\right).
  \]
\end{define}

Similarly, we can use the map $\sigma_{\Cdot}$ for following convenient notation:
\begin{define}[action of $\mathcal{S}_n$]
\label{def:actions}
  For $\tau \in \mathcal{T}_n, \rho \in \mathcal{S}_n,
       C \in M \subseteq \mathbb{R}^{n \times n}, T \in 2^{\mathcal{T}_n}$,
  we define
  \begin{align*}
    \tau \rho & \coloneqq \sigma_\tau \rho, \\
    \rho \, \tau & \coloneqq \rho \, \sigma_\tau, \\
    \rho \, T & \coloneqq \pi\left(\left\{ \rho \, \sigma_\eta \mid \eta \in T \right\}\right), \\
    \rho \, C & \coloneqq \left(c_{\rho\left(i\right),\rho\left(j\right)}\right)_{i,j \in \mathcal{N}_n}, \\
    \rho M & \coloneqq \left\{ \rho \, \widehat{C} \mid \widehat{C} \in M \right\}.
  \end{align*}
\end{define}

We can see that $\rho \, \tau$ is associated with the tour $\tau$ over
cities reordered by $\rho$, and if we consider $\tau \rho$ to be a
reordering of the tour $\tau$, following result becomes intuitively
agreeable:

\begin{proposition}
\label{prop:rotinv}
  For any permutation $\rho \in \left<\left(1 \; 2 \; \cdots \; n \right)\right>
  = \left\{{\left(1 \; 2 \; \cdots \; n \right)}^m \mid m \in \mathbb{Z} \right\}$,
  \[
    \omega_C\left(\tau\right) = \omega_C\left(\tau \rho\right)
  \]
  holds true for all $\tau \in \mathcal{T}_n$ and all $C \in \mathbb{R}^{n \times n}$.
\end{proposition}
\begin{proof}
  Consider following natural isomorphism between $\mathbb{Z}/n\mathbb{Z}$ and $\mathcal{N}_n$:
  for $i \in \mathbb{Z}$, let
  \[
    d\left(i\right) \coloneqq \left(\left(i-1\right)\operatorname{mod} n\right)+1.
  \]
  We have $d\left(\mathbb{Z}\right) = \mathcal{N}_n$,
  and $d\restriction_{\mathcal{N}_n} = \operatorname{id}_{\mathcal{N}_n}$
  is trivially a bijection (as is $\rho$); further,
  \begin{align}
    \label{eq:add}
    d\left(x+y\right) =
    d\left(d\left(x\right) + d\left(y\right)\right)
    \quad \forall x \in \mathbb{Z} \; \forall y \in \mathbb{Z},
  \end{align}
  and with $d\left(n+1\right) = 1$ we can now write the cost function from \cref{def:cost} as
  \begin{equation}
  \label{eq:cost}
    \omega_C\left(\tau\right) =
    \sum_{i=1}^n c_{\sigma_\tau\left(i\right),\sigma_\tau\left(d\left(i+1\right)\right)}.
  \end{equation}
  We also note that \exists $K \in \mathcal{N}_n$ s.t.\ 
  $\rho\left(i\right) = d\left(i+K\right) \; \forall i \in \mathcal{N}_n$,
  and, using \cref{eq:add}, obtain
  \begin{align}
    \label{eq:addadd}
    \begin{split}
    \rho \left(d\left(i+1\right)\right)
    & =
    d\left(d\left(i+1\right)+K\right) =
    d\left(d\left(i+1\right)+d\left(K\right)\right) =
    d\left(i+1+K\right) =
    \\
    & =
    d\left(d\left(i+K\right)+d\left(1\right)\right) =
    d\left(d\left(i+K\right)+1\right) =
    d\left(\rho\left(i\right)+1\right)
    \end{split}
  \end{align}
  for any city $i$.
  It now follows that
  \begin{align*}
    \omega_C\left(\tau \rho\right) =
    \omega_C\left(\pi\left(\sigma_\tau \circ \rho\right)\right)
    & \stackrel{\eqref{eq:cost}}{=}
    \sum_{i=1}^n c_{\sigma_\tau\left(\rho\left(i\right)\right),
                    \sigma_\tau\left(\rho\left(d\left(i+1\right)\right)\right)}
    =
    \\
    & \stackrel{\eqref{eq:addadd}}{=}
    \sum_{k=1}^n c_{\sigma_\tau\left(k\right),
                    \sigma_\tau\left(d\left(k+1\right)\right)}
    \stackrel{\eqref{eq:cost}}{=}
    \omega_C\left(\tau\right).
  \end{align*}
\end{proof}

This shows, in particular, how restricting the tour set in the TSP to a
fixed starting city does not necessarily signify a qualitative restriction
of solutions set.

We now want to establish a connection between permutations of cities,
reordered tours and solutions to the TSP.

\begin{lemma}
\label{lemma:ordermat}
  For any $\rho \in \mathcal{S}_n, C \in \mathbb{R}^{n \times n}, \tau \in \mathcal{T}_n$,
  \[
    \omega_C\left(\rho\,\tau\right) = \omega_{\rho\,C}\left(\tau\right)
  \]
  holds true.
\end{lemma}
\begin{proof}
  Borrowing definition of $d$ from the proof of \cref{prop:rotinv},
  and using \cref{eq:cost} along with \cref{def:actions}, we obtain
  \begin{align*}
    \omega_{\rho\,C}\left(\tau\right) =
    \sum_{i=1}^n c_{\rho\left(\sigma_\tau\left(i\right)\right),
                    \rho\left(\sigma_\tau\left(d\left(i+1\right)\right)\right)} =
    \omega_C\left(\rho \circ \sigma_\tau\right) =
    \omega_C\left(\rho\,\tau\right).
  \end{align*}
\end{proof}

\begin{corollary}[reordered TSP]
\label{cor:reorder}
  For any $\rho \in \mathcal{S}_n, C \in M \subseteq \mathbb{R}^{n \times n},
  \tau \in \mathcal{T}_n$,
  \annotation{,,Latter for any pair of compatible orderings $L, \rho L$'' or some such necessary?}
  \begin{align*}
  \begin{split}
    \operatorname{tsp}^\ast_{M,\rho T}\left(C\right)
    & =
    \rho \: \operatorname{tsp}^\ast_{\rho M,T}\left(\rho\,C\right),
    \\
    \operatorname{tsp}_{M,\rho T}\left(C\right)
    & =
    \pi\big( \rho \: \operatorname{tsp}_{\rho M,T}\left(\rho\,C\right) \big).
  \end{split}
  \end{align*}
  %% Latter equality holds for any two orderings of tours where one is image of the other under $\rho$.
  %% (which one exactly?)
\end{corollary}
\begin{proof}
  Using \cref{lemma:ordermat} and \cref{def:tsp}, we obtain
  \begin{align*}
    \begin{split}
    \operatorname{tsp}^\ast_{\left\{\rho\,C\right\},T}\left(\rho\,C\right)
    & =
    \argmin_{\tau \in T} \omega_{\rho\,C}\left(\tau\right) =
    \argmin_{\tau \in T} \omega_{C}\left(\rho\,\tau\right) =
    \\
    & =
    \rho^{-1} \: \argmin_{\rho\tau \in \rho T} \omega_{C}\left(\rho\,\tau\right) =
    \rho^{-1} \: \operatorname{tsp}^\ast_{\left\{C\right\},\rho T}\left(C\right),
    \end{split}
  \end{align*}
  from which the rest follows.
\end{proof}

\subsection{Tour sets as neighbourhoods}

Given a non-empty set of tours $T$, we can choose some (any) element
$\tau^\ast \in T$ and consider $T$ to be a set of permutations of
$\tau^\ast$ --- its action then defines a neighbourhood in $\mathcal{T}_n$:

\begin{define}[induced neighbourhood]
  \label{def:induced}
  Given a set of tours $T \subseteq \mathcal{T}_n$ and a tour $\tau^\ast \in T$,
  define $F_T$ to be the map
  \[
    F_T: \mathcal{T}_n \to 2^{\mathcal{T}_n}, \quad
    \tau \mapsto
    \pi \left(
      \left\{ \sigma_{\tau} \circ \sigma_{\tau^\ast}^{-1} \circ \sigma_{\tau^\prime}
              \mid \tau^{\prime} \in T\right\}
    \right)
    =
      \left(\sigma_{\tau} \circ \sigma_{\tau^\ast}^{-1}\right) T.
  \]
  We call $F_T$ {\defstyle neighbourhood induced by} $T$
  ({\defstyle centred at} or {\defstyle with centre} $\tau^\ast$).
\end{define}

\begin{figure}[bht]
  \centering
  \includegraphics[width=0.49\textwidth]{../plot/build/ext-1.mps}
  \caption{A non-empty set of tours $T$ induces a neighbourhood $F_T$.}
\end{figure}

\begin{remark}
  It is quickly verified that
  $\tau \in F_T\left(\tau\right) \; \forall \tau \in \mathcal{T}_n,$
  i.e.\ $F_T$ is in fact a neighbourhood according to our definition.
  We further have $F_T\left(\tau^\ast\right) = T$.
  We deliberately omit the choice of centre from notation of induced
  neighbourhood, treating it as implicit parameter which is usually
  to be established along with the set $T$.
\end{remark}

If we now can solve the TSP efficiently over a fixed set of tours $T$
(for arbitrary cost matrices), choosing a $\tau^\ast \in T$ immediately
allows us to construct local search over $F_T$:
applying \cref{cor:reorder} to \cref{def:induced}, we arrive at
\[
  l_C\left(\tau\right) =
  \pi\left(\rho\,\operatorname{tsp}_{\rho M,T}\left(\rho\, C\right)\right),
  \quad
  \text{where}\; \rho = \sigma_\tau \sigma_{\tau^\ast}^{-1},
\]
(which indeed mirrors our implementation exactly),
and choosing $\tau^\ast$ to be the starting tour in \cref{def:ils} then
yields iterated local search.
%
% OUR CODE: see tspsearch/itersearch.sml
%
%   inv_order = \sigma_{\tau^\ast}^{-1}
%   lookup t = \sigma_t \circ inv_order
%   map x y = x o y for permutation y
%

\clearpage

\dictum[L. Peter Deutsch]{To iterate is human, to recurse divine.}
\section{Theory}

\annotation{Move some of this to abstract?}
Dynamic programming is a fruitful approach to tackling many problems in
combinatorial optimization --- this specifically includes traveling
salesman problem and a number of its special cases.  Here we want to
present two exponential neighbourhoods which are polynomially solvable via
dynamic programming solutions.

While the first one --- {\defstyle pyramidal tours} --- can be considered
widely known, less so is its extension to a viable local search heuristic
which we will present herein.  The second --- {\defstyle strongly balanced
  tours} --- is somewhat more involved in its construction and so had yet
to see an implementation until now, which can be seen as essential
motivation behind this project.

\subsection{Pyramidal tours}

\annotation{Who was first?  Bibliography: TODO throughout.}
Pyramidal TSP was first described by (whom? \cite{bellman,gilmore}?)
and can be defined as follows:

\begin{define}[pyramidal TSP]
  A simple path
  \[
  \left( p_1, \ldots, p_k, q_1, \ldots, q_m \right)
  \; \text{s.t.} \;
  \begin{cases}
    p_i < p_{i+1} \; & \forall i \in \mathcal{N}_{k-1},\\
    q_j > q_{j+1} \; & \forall j \in \mathcal{N}_{m-1},
  \end{cases}
  \]
  is called {\defstyle pyramidal}.  We shall denote by
  $\operatorname{Pyr}_n$ the set of all pyramidal tours in $\mathcal{T}_n$,
  and call TSP restricted to $\operatorname{Pyr}_n$ {\defstyle pyramidal TSP}.
\end{define}
We note here that the set $\operatorname{Pyr}_n$
induces a neighbourhood in $\mathcal{T}_n$ with centre
$\left(1, 2, \ldots, n, 1\right)$.

\begin{figure}[bht]
  \centering
  \includegraphics[width=0.49\textwidth]{../plot/build/pyr-2.mps}
  \caption{%
    For a pyramidal tour $\tau$, connected plot of $\sigma_\tau$'s
    (function) graph resembles a pyramid (here: $n = 5$, plot repeated at $1$
    for cosmetic reasons).
  }
\end{figure}

This definition of pyramidal tours, while explaining the name, does not
yet offer an obvious different solution to the corresponding optimization
problem.  To achieve that, first we observe that every pyramidal tour
necessarily takes the shape
\[
\left(1, p_1, \ldots, p_k, n, q_1, \ldots, q_m, 1 \right)
\; \text{with} \;
\begin{cases}
  p_i < p_{i+1} \; & \forall i \in \mathcal{N}_{k-1},\\
  q_j > q_{j+1} \; & \forall j \in \mathcal{N}_{m-1},
\end{cases}
\]
and then notice that for any city, we can choose it to be
either element of $\left\{p_1,\ldots,p_k\right\}$
or element of $\left\{q_1,\ldots,p_m\right\}$,
and once we made that that choice, the city in question has unique position in the tour.
This argument makes $\left|\operatorname{Pyr}_n\right| = \Theta\left(2^n\right)$
evident and following construction transparent:

\begin{proposition}[recursive structure of $\operatorname{Pyr}_n$]
\label{prop:pyrall}
  For cities $i,j$ in $\mathcal{N}_n$,
  let $V\left(i,j\right)$ denote the set of all pyramidal paths
  $\left(i,p_1,\ldots,p_m,j\right)$
  in $\mathcal{P}_n$
  s.t.\ $\left\{p_1,\ldots,p_m\right\} = \left\{k,\ldots,n\right\}$
  with $k = \max\left\{i,j\right\}+1$.  Then
  \begin{align}
    \label{eq:pyrall}
    V\left(i,j\right) & =
    \begin{cases}
      \left\{\left(i,j\right)\right\}, & n \in \left\{i,j\right\},
      \\
      \left(i\right) \oplus V\left(k,j\right)
      \;\bigcup\;
      V\left(i,k\right) \oplus \left(j\right)
      & \text{otherwise ($k$ as above)},
    \end{cases}
  \end{align}
  and $\operatorname{Pyr}_n = V\left(1,1\right)$.
\end{proposition}
\begin{proof}
  The second case in \cref{eq:pyrall} becomes apparent when,
  using preceding argument,
  we choose position for each city one at a time in increasing order.
  The rest follows directly from our definition of $V$.
\end{proof}

\begin{figure}[hbt]
  \centering
  \includegraphics[width=0.49\textwidth]{../plot/build/pyr-3.mps}
  \label{fig:pyrpart}
  \caption{$\operatorname{Pyr}_n$ constructed one city at a time.}
\end{figure}

This translates directly onto a dynamic programming solution to pyramidal TSP:
\begin{corollary}[dynamic programming solution to pyramidal TSP]
\label{cor:pyrdp}
\annotation{improve layout}
  For a suitable tour-valued definition of $\argmin^\ast$, the recurrence relation
  \begin{align}
    \label{eq:pyrdp}
    \Phi_C\left(i,j\right) & \coloneqq
    \begin{cases}
      \left(i,j\right), & n \in \left\{i,j\right\}, \\
      %\displaystyle \adjustlimits \min_L \argmin_T \omega_C & \text{otherwise},
      {\displaystyle \argmin_T}^\ast \omega_C & \text{otherwise},
    \end{cases}
    \\
    \text{where} & \phantom{\coloneqq}
    T \coloneqq
    \left\{
    \left(i\right) \oplus \Phi_C\left(k,j\right),
    \Phi_C\left(i,k\right) \oplus \left(j\right)
    \right\},
    \nonumber
    \\
    & \phantom{\coloneqq}
    k \coloneqq \max\left\{i,j\right\}+1,
    \nonumber
  \end{align}
  produces, for arbitrary cost matrices, a well-defined map $\Phi_C$ on $\mathcal{N}_n^2$,
  and via
  \[
    \phi~:~C~\mapsto~\Phi_C\left(1,1\right)
  \]
  a map on $\mathbb{R}^{n \times n}$.
  For latter,
  \[
    \phi = \operatorname{tsp}_{\mathbb{R}^{n \times n},\operatorname{Pyr}_n}
  \]
  holds true.
\end{corollary}
\begin{proof}
  Borrowing defition of $V$ from \cref{prop:pyrall}, we first note that,
  per induction over \eqref{eq:pyrall}, $V\left(i,j\right)$ is never empty.

  If we now choose $\argmin^\ast$ to select from two equal cost tours in
  $T$ one deterministically and independently from $C$ (say, the first of
  the two options in definition of $T$ above), then this, per construction,
  produces a linear order on paths in $V\left(\mathcal{N}_n^2\right)$, and
  hence also on $\operatorname{Pyr}_n$.

  We then see per induction over \cref{eq:pyrall,eq:pyrdp} that for all
  cities $i,j$ and cost matrices $C$, $\Phi_C\left(i,j\right)$ is the
  smallest (according to said order) cost minimizing tour in $V\left(i,j\right)$,
  %\[
  %  \Phi_C\left(i,j\right) = \argmin^\ast \omega_C V\left(i,j\right)
  %\]
  from which the rest follows.
\end{proof}

Recurrence relation such as the one introduced above are well visualized
via so called {\defstyle recursion tree}~--- a directed graph in which
nodes correspond to different arguments to the relation, and edges
represent recursive dependence.  For pyramidal TSP, \cref{fig:pyratrace}
shows such a graph.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.92\textwidth]{../plot/build/trace_apyr.pdf}
\caption{Pyramidal (a)TSP recursion tree along with values of $\Phi_C$
  from \cref{cor:pyrdp} for a sample cost matrix $C$ ($n=5$).}
\label{fig:pyratrace}
\end{figure}

%\begin{figure}[htbp]
%\null\hfill%
%\subfloat[aTSP]{%
%  \includegraphics[width=0.62\textwidth]{../plot/build/trace_apyr.pdf}
%}\hfill\null
%\null\hfill%
%\subfloat[sTSP]{%
%  \includegraphics[width=0.36\textwidth]{../plot/build/trace_pyr.pdf}
%}\hfill\null
%\caption{Pyramidal TSP: recursion tree.}
%\label{fig:pyrtraces}
%\end{figure}

\subsection{Recursion and complexity}

While \cref{cor:pyrdp} offers a solution to the pyramidal TSP, the function
as it is presented in \cref{eq:pyrdp} does not yet necessarily translate
onto an efficient computer program.
For this, we need to perform the additional step of {\defstyle memoization}.

The term, coined in computing (from {\defstyle memo}), denotes the
technique of evaluating a function no more than once at any point in its domain,
storing evaluation results somewhere and retrieving (i.e.\ substituting) them for
subsequent evaluations.
Not unnatural to computations by hand, memoization can formally be seen as
evaluation, in place of a function over some set, said function's graph over
the set.
In what now follows, $X$ can thus be seen as a memory holding evaluation results:

\begin{proposition}[memoized solution to pyramidal TSP]
\label{prop:pyrmem}
\annotation{better layout via alignedat?}
  Given a set of cities $\mathcal{N}_n$, let, for cities $i,j$ and cost matrix $C$,
  \begin{align}
    \label{eq:pyrmem}
    \widehat{\Phi}_C\left((i,j),X\right) & \coloneqq
    \begin{cases}
      \left(v^\ast,X\right), & \left((i,j),v^\ast\right) \in X \;\text{for some}\; v^\ast,
      \\
      \left((i,j),X \cup \left\{\left((i,j),(i,j)\right)\right\}\right) & \text{otherwise, if}\; n \in \left\{i,j\right\},
      \\
      \left(v,X^{\prime\prime} \cup \left\{\left((i,j),v\right)\right\}\right) & \text{otherwise, where}
    \end{cases}
    \\
    v & \coloneqq \argmin \omega_C
    \;\;\text{over}\;\; {\left\{(i) \oplus v^\prime, v^{\prime\prime} \oplus (j) \right\}},
    \nonumber
    \\
    \left(v^{\prime\prime},X^{\prime\prime}\right) & \coloneqq \widehat{\Phi}_C\left((i,k),X^\prime\right),
    \nonumber
    \\
    \left(v^{\prime},X^{\prime}\right) & \coloneqq \widehat{\Phi}_C\left((k,j),X\right),
    \nonumber
    \\
    k & \coloneqq \max \left\{i,j\right\} + 1.
    \nonumber
  \end{align}
  Then, borrowing definition of $\Phi_C$ from \cref{cor:pyrdp},
  \[
    \widehat{\Phi}_C\left((1,1),\varnothing\right) = \left(\Phi_C\left(1,1\right),E\right),
  \]
  where $E$ is the graph of $\Phi_C$ over $\mathcal{N}_n^2 \setminus \left\{(n,n)\right\}$.
\end{proposition}
\begin{proof}
  Comparing the construction of $\widehat{\Phi}_C$ in \cref{eq:pyrmem} to 
  that of $\Phi_C$ in \cref{eq:pyrdp},
  we see that if $X$ in \eqref{eq:pyrmem} is a subset of $\Phi_C$'s graph,
  then so is the second element returned by
  $\widehat{\Phi}_C$, and with this the rest follows.
\end{proof}

\begin{remark}
\label{rem:timeass}
This gives us a viable way of computing $\Phi_C\left(1,1\right)$, and, by extension,
$\operatorname{tsp}_{\operatorname{Pyr}_n}$ --- in fact, our code, which
generated \cref{fig:pyratrace} as its execution trace, closely mirrors this exact
definition.
It is also a reasonably efficient implementation, provided that we are
allowed following assumptions:
  \begin{enumerate}[(i)]
    \item
      $\argmin \omega_C$ in definition of $\Phi_C$ above is computable in constant time:
      this is usually achieved by returning tour cost along with the
      tour\footnote{%
        It should be noted, without too much detail, that this also spares
        us the need to construct all but the optimum tour.
      };
    \item
      tour concatenation in said definition is computable in constant time:
      in this case, an obviously reasonable assumption;
    \item
      memory access (search for $v^\ast$ in first case of \eqref{eq:pyrmem},
      and set union in the other two) can be accomplished in constant time:
      sometimes overlooked, this is equivalent to existence of efficient hashing
      function on the domain of the map which is to be memoized ---
      in this case, $(i,j) \mapsto (n+1)\times i + j$ is one such function.
  \end{enumerate}
\end{remark}

Note that evaluating $\widehat{\Phi}_C$ following its definition corresponds to
depth first search over the recursion tree, which is quadratic in number of nodes
as well as number of edges --- if we now consider memoization to be what
is usually called edge marking in that it guarantees that every edge
is visited no more than once, we intuitively arrive at following result:

\begin{corollary}
\label{cor:pyrtime}
  Pyramidal TSP is polynomially solvable (under assumptions made in \cref{rem:timeass}).
\end{corollary}
\begin{proof}
  Consider $\widehat{\Phi}_C\left((i,j),X\right)$ as defined in \cref{prop:pyrmem}.
  If, for a bound $M$,
  we now rewrite the recurrence relation from definition of $\widehat{\Phi}_C$ as
  \begin{align}
    \label{eq:pyrtime}
    R\left((i,j),X\right) & \coloneqq
    \begin{cases}
      \left(M,X \cup \left\{(i,j)\right\}\right) & (i,j) \in X \;\text{or}\; n \in \left\{i,j\right\},
      \\
      \left(M+t,X^{\prime\prime} \cup \left\{(i,j)\right\}\right) & \text{otherwise, where}
    \end{cases}
    \\
    t & \coloneqq t^{\prime} + t^{\prime\prime},
    \nonumber
    \\
    \left(t^{\prime\prime},X^{\prime\prime}\right) & \coloneqq R\left((i,k),X^\prime\right),
    \nonumber
    \\
    \left(t^{\prime},X^{\prime}\right) & \coloneqq R\left((k,j),X\right),
    \nonumber
    \\
    k & \coloneqq \max \left\{i,j\right\} + 1,
    \nonumber
  \end{align}
  and define $\operatorname{time} \coloneqq (x,y) \mapsto x$,
  %$\operatorname{mem} \coloneqq (x,y) \mapsto y$ and
  $T \coloneqq \operatorname{time} \circ R$,
  then for some such $M$
  the maximum number of steps in which we can compute
  $\widehat{\Phi}_C\left((i,j),\varnothing\right)$
  equals to
  $T\left((i,j),\varnothing\right)$
  for any pair of cities.
  We now want to show that
  \[
    T\left((1,1),\varnothing\right) = \mathcal{O}\left(n^2\right).
  \]
  \annotation{alignment}
  Let us expand
  \begin{align*}
    T\left((1,1),\varnothing\right) & =
    M + T\left((1,2),X_{1,2}^{1,1}\right)
      + T\left((2,1),X_{2,1}^{1,1}\right) =
    \\ & = M + 2M + T\left((1,3),X_{1,3}^{1,2}\right)
                  + T\left((3,2),X_{3,2}^{1,2}\right) +
             \\ & + T\left((3,1),X_{3,1}^{2,1}\right)
                  + T\left((2,3),X_{2,3}^{2,1}\right) =
    \\ & = M + 2M + 2M\cdot 2 +
    \\ & + T\left((1,4),X_{1,4}^{1,3}\right)
         + T\left((4,3),X_{4,3}^{1,3}\right)
    \\ & + T\left((3,4),X_{3,4}^{3,2}\right)
         + T\left((4,2),X_{4,2}^{3,2}\right)
    \\ & + T\left((3,4),X_{3,4}^{3,1}\right)
         + T\left((4,1),X_{4,1}^{3,1}\right)
    \\ & + T\left((2,4),X_{2,4}^{2,3}\right)
         + T\left((4,3),X_{4,3}^{2,3}\right) = \ldots
  \end{align*}
  where the sets $X_{i,j}^{k,l}$ correspond to evaluation of $R$ as defined.
  Here we make a critical observation:
  any two nodes in the recursion tree given by \cref{eq:pyrdp} have a common ancestor,
  so at any point in our expansion,
  given a pair $(i,j)$, it must lie in all but last of $X_{i,j}^{k,l}$,
  hence $T\left((i,j),X_{i,j}^{k,l}\right) = M$ for all but last such contributor to the sum.
  We thus arrive at
  \annotation{recheck}
  \begin{align*}
    T\left((1,1),\varnothing\right) & \leq
    M + 2M \left(1 + 2 + \cdots + n\right) +
        2M \left(1 + 2 + \cdots + (n-2)\right) +
    \\
    & + \sum_{i=1}^{n-1} \left(
        T\left((i,n),X_{i,n}\right)
      + T\left((n,i),X_{n,i}\right)
    \right)
    = \mathcal{O}\left(n^2\right).
  \end{align*}
\end{proof}

This illustrates how, given a recurrence relation, memoization technique
can generally be used to achieve time complexity which is asymptotically no
worse than the size of the recursion tree --- which we think can be seen as
the concept behind dynamic programming.

In computing, memoization can be applied to any function values of which
depend only on its arguments --- such a function is also said to be
{\defstyle referentially transparent} (in mathematics, every well-defined
map is referentially transparent; in computing, depending on programming
language, the concept of function may allow for implicit dependency on
environment --- i.e.\ some mutable state).

\begin{remark}
  The solution presented in \cref{prop:pyrmem} incurs quadratic space
  overhead.  We would like to mention here that linear space complexity is
  achievable if we rewrite said solution as a so called {\defstyle
    tail-recursive} function.  We shall leave out the details at this
  point, only noting that this is equivalent to breadth-first search over
  the recursion tree.

  It should also be noted that the tree size can be halved if we
  restrict ourselves to symmetric matrices --- as can be seen in
  \cref{fig:pyrstrace}.
\end{remark}

\begin{figure}[hbt]
\centering
\includegraphics[width=0.55\textwidth]{../plot/build/trace_pyr.pdf}
\caption{A sample trace of our implementation of pyramidal sTSP $(n = 5)$.}
\label{fig:pyrstrace}
\end{figure}

\begin{remark}[TODO]
\annotation{add this to appropriate places in paper}
\annotation{Demidenko conditions: interesting?}
While determining if a given TSP instance is pyramidal is NP-hard
\cite{baki}, a number of polynomially testable classes which are
pyramidally solvable exist \cite{baki,gilmore} --- still, those are not
widely common.
Also: what was the pyramidal vs k-opt coverage?
\end{remark}

Before we turn our attention to the next neighbourhood, there is one last
point that we feel needs to be addressed: while we have discussed
depth-first search and mentioned breadth-first search computation over the
recursion tree, we have not yet considered the bottom-up approach widely
used in imperative programming.

While its merits and caveats compared to the functional approach are
manyfold, there is one important requirement said technique impedes on the
problem: for it to work, terminal nodes (or leafs) of the recursion tree
have to be feasibly computable beforehand.  While this presents no problem
for pyramidal TSP, this is much less the case for the neighbourhood we are
about to see --- which made bottom-up approach ultimately unsuitable for
this project.

\clearpage

\subsection{Strongly balanced tours}

\annotation{TODO FROM HERE}
\clearpage

\annotation{Treatment of four point conditions needed here?}
Another class of sTSP is the {\em Relaxed Supnick TSP} \/(RS-TSP), which is
obtained by restricting considered instances via a simple four-point
condition:
\[
  c_{ik} + c_{jl} \leq c_{il} + c_{jk} \quad \forall \; 1 \leq i < j < k < l \leq n,
\]
where $\left(c_{ij}\right)$ is the distance matrix.

While it has been shown that RS-TSP is NP-hard, an exponential subset of
said problem which is polynomially solvable has also been found.

\subsection{Strongly balanced tours and linear time conjecture}

It can subsequently be shown that the set of strongly balanced tours contains optimal solution
to TSP restricted to Relaxed Supnick matrices which additionaly satisfy
\[
  c_{il} + c_{jk} + c_{km} \geq c_{ik} + c_{jm} + c_{kl}
  \quad \forall i < j < k < l < m
\]
and that this condition can be checked in quadratic time.

If we further restrict this set by
\[
  c_{ji} + c_{kl} \leq c_{jl} + c_{ki} \quad \forall i<j, \; j+h \leq k < l
\]
for a given constant $h$, then we can show that the optimum can be found
amongst balanced tours for which number of paths of each element of $\mathcal T$
does not exceed $h/2 + 1$, and for such families size of ${\mathcal T}_n$ is bounded
by a constant for given $h$ \cite{fpneighb,fpclass}.

Number of unique node types, which presents upper bound for tree width, can
be seen in \autoref{tbl:nodeTypes}.  A breadth-first search implementation
could be used to naturally compute the tree width.

\annotation{Show how number of tours is $\Omega(2^n)$.}
Noting how the definition of strongly balanced tours naturally
yields a dynamic programming recursion, this results in a linear time
solution for the given exponential neighbourhood.

\setlength{\aboverulesep}{0pt}
\setlength{\belowrulesep}{0pt}
\renewcommand{\tabcolsep}{9pt}
\setlength{\extrarowheight}{1.1ex}
\newcolumntype{g}{>{\columncolor{Gray}}c}

\begin{table}[htpb]
\centering
    \mbox{%
      \pgfplotstabletypeset[
        col sep=space,
        std=-10:10,
        every head row/.style={output empty row},
        every head row/.style={%
          before row={\toprule},
          after row={\midrule}
        },
        display columns/0/.style={%
          column name={\bfseries Node size limit},
          column type={g}
        },
        display columns/1/.style={%
          column name={\bfseries Node types},
          column type={r}
        },
        display columns/2/.style={%
          column name={\bfseries Stable at depth},
          column type={g}
        },
        every last row/.style={after row=\bottomrule},
        %multicolumn names,
      ]{../plot/data/num\string_types.csv}%
    }
\caption{Number of node types encountered.}%
\label{tbl:nodeTypes}%
\end{table}

\begin{figure}[htbp]
\makebox[\textwidth][c]{%
  \includegraphics[width=1.21\textwidth]{../plot/build/trace_bal.pdf}
}
\caption{%
  A trace of our implementation's strongly balanced search graph traversal over $K_8$.  Here, maximum node size is 2.
}
\end{figure}

\subsection{Local search and flowers}

Pyramidal flower: \cite{belperm}.

\clearpage

\dictum[Donald Knuth]{You’re bound to be unhappy if you optimize everything.}
\section{Implementation}

\subsection{Key features}
\annotation{TODO}

Written in {\ttfamily Standard ML}.
Usable via SML REPL, standalone executable or shared library.
Tested under multiple software (see \autoref{app:compiler}) and OS/hardware platforms --
Linux (amd64) and Windows (x86) (MinGW-crosscompiled).

\annotation{Tradeoff illustration: provide LOC count?}
General dynamic programming results implementation via search graph traversal (simple depth-first search),
making a tradeoff between performance and extendibility.
BFS could be somewhat faster, but for our research dfs is enough.
Memoization via hash tables.

\annotation{Can we rename repo?}
This project's sources are available
\href{https://bitbucket.org/mad_hatter/rstsp/}{online}\footnote{\url{https://bitbucket.org/mad_hatter/rstsp/}}.

\subsection{Runtime behaviour}
\annotation{TODO}
\annotation{Describe \autoref{fig:benchRAND}.}

Clearly pronounced linear runtime for str.~balanced search, apparently heavy overhead penalty.
Pyramidal faster but str.~balanced eventually takes over.
See \autoref{fig:benchRAND}.
Memory usage not seriously measured, since bottleneck here is runtime.

\begin{figure}[htbp]
\null\hfill%
\subfloat[higher node sizes]{%
  \includegraphics[width=0.49\textwidth]{../plot/build/mlton_time_random_low.pdf}
}\hfill\null
\null\hfill%
\subfloat[medium node sizes]{%
  \includegraphics[width=0.49\textwidth]{../plot/build/mlton_time_random_fast.pdf}
}\hfill\null\\
\null\hfill%
\subfloat[low node sizes]{%
  \includegraphics[width=0.59\textwidth]{../plot/build/mlton_time_random_steady.pdf}
}\hfill\null\\
\null\hfill%
\subfloat[pyramidal vs str.~balanced/m3]{%
  \includegraphics[width=0.49\textwidth]{../plot/build/mlton_time_random_med.pdf}
}\hfill\null
\null\hfill%
\subfloat[pyramidal vs str.~balanced/m4]{%
  \includegraphics[width=0.49\textwidth]{../plot/build/mlton_time_random_hi.pdf}
}
\hfill\null
\caption{Single traversal running times (Linux 3.10.17 ({\ttfamily x86\_64}) @ i5-2520M).}
\label{fig:benchRAND}
\end{figure}

\subsection{Tour benchmarks}

\annotation{TODO}
Describe results, add Relaxed Supnick matrices benchmarks (!),
prettier (also, split) histograms?, plot iterations behavior? -- see \autoref{fig:benchTSPLIB}.

In what limited testing we have done, pyramidal still performs better.

For str.~balanced: adaptive search seems to perform better
than always choosing from $2n+1$ specific permutations.

\begin{figure}[htbp]
\null\hfill%
\subfloat[random --- tour length]{%
  \includegraphics[width=0.69\textwidth]{../plot/build/random_val.pdf}
}\hfill\null\\
\null\hfill%
\subfloat[tsplib \& vlsi --- tour quality]{%
  \includegraphics[width=0.69\textwidth]{../plot/build/tsplib_val.pdf}
}\hfill\null\\
\null\hfill%
\subfloat[tsplib \& vlsi --- time needed]{%
  \includegraphics[width=0.69\textwidth]{../plot/build/tsplib_time.pdf}
}\hfill\null
\caption{Benchmarks --- small instances.}
\label{fig:benchTSPLIB}
\end{figure}

\clearpage

\dictum[Arthur Bloch]{Enough research will tend to support your conclusions.}
\section{Conclusions}

\subsection{Results obtained}
\annotation{TODO}
First implementation of str.~balanced search.
Other dyn.pr.\ cases easy to plug in.
Some benchmarks.
Preprocessing offers no gain.

\begin{figure}[htbp]
%\begin{wrapfigure}{r}{0.5\textwidth}
\centering
\includegraphics[width=0.54\textwidth]{./tsp.png}
\caption*{\captionsize Source: \small \url{https://xkcd.com/399/}.}
%\end{wrapfigure}
\end{figure}

\subsection{Areas for further research}
\annotation{TODO}

Are these heuristics better for aTSP\@?
Untested: other metrics or higher dimensions, dedicated implementations' performance.
Further heuristics combinations.
Branch cutting.
Different permutations set for str.~balanced tours?
Concurrency.

\annotation{TODO}

Dedicated implementations (pyramidal: bottom up easy) fast, but not always feasible (str.~balanced: machine-generated).
Naive concurrency (see the {\ttfamily experimental} code) not easily applicable in general case (dense search tree).
Potentially fruitful approaches: tuple spaces, message passing languages, etc
(PolyML/Linda?, manticore, jocaml, mythryl, aliceml, clojure/clotilde, scala/akka, $\ldots$).

%% lualatex+metapost demo:
%\begin{figure}[htbp]
%\centering%
%\begin{mplibcode}
%  beginfig(0)
%    pair p[];
%    p1 = (0,0); p2 = (100,0); p3 = (200,0); p4 = (300,0); p5 = (400,0);
%    pair c[];
%    c1 = (50,20); c2 = (210,30); c3 = (250,-10); c4 = (100,-20);
%    path a;
%    a = p1 .. controls c1 ..
%        p2 .. controls c2 ..
%        p4 ..
%        p5 .. controls c3 ..
%        p3 ..  controls c4 ..
%        cycle ;
%    for i = 1 upto length a:
%      dotlabel.top(decimal i, p[i]);
%      drawarrow subpath (i-1,i) of a withcolor 0.2;
%    endfor
%  endfig;
%\end{mplibcode}
%\ 
%\caption{A pyramidal tour over $K_5$.}
%\end{figure}

%\input{problem1.tex}

%\appendix
%\addcontentsline{toc}{chapter}{Appendices}
%\makeatletter
%\addtocontents{toc}{\let\protect\l@chapter\protect\l@section}
%\makeatother
%\chapter{First Appendix}
%\chapter{Second Appendix}

\clearpage
\begin{appendices}

\makeatletter
\addtocontents{toc}{\let\protect\l@chapter\protect\l@section}
\makeatother

%\section{Code Index}
%\lstlistoflistings%

\section{Shared Library Interface}
\label{app:so}

\needspace{5\baselineskip}
\mylisting[
  caption={[FFI usage example]FFI usage example.},
  firstline=8,fontadjust,language=C,
  label=lst:so]{../src/rstsp/librstsp/test.c}

\section{Sample REPL Session}

%\input{testapp.tex}

\section{Compiler Support}
\label{app:compiler}
\input{sml-support.tex}

\end{appendices}

%\printindex
\printbibliography%

\end{document}

