%
% $Id$
% $Author$
% $Date$
% $Rev: 34 $
%

%\documentclass[titlepage,index=totoc,bibliography=totoc]{scrartcl}
\documentclass[index=totoc,bibliography=totoc]{scrartcl}
\KOMAoptions{fontsize=11pt}
%\KOMAoptions{BCOR=0.25mm}
%\usepackage[left=3.1cm, right=3.1cm]{geometry}

\usepackage{mathdesign}
\usepackage[no-math]{fontspec}
\defaultfontfeatures{Ligatures=TeX}
\setmainfont[Numbers=OldStyle]{Latin Modern Roman}
%\setmainfont[Numbers=OldStyle]{CMU Serif}
%\setmainfont[Numbers=OldStyle]{Gentium}
%\setmainfont[Numbers=OldStyle]{EB Garamond}
\setsansfont[Numbers=OldStyle]{CMU Sans Serif}
%\setsansfont{Droid Sans}
%\setmonofont{CMU Typewriter Text}
\setmonofont[Scale=0.9]{Droid Sans Mono}
%\setmonofont{DejaVu Sans Mono}
\newfontfamily\CodeFont[Scale=0.85]{DejaVu Sans Mono}
%\newfontfamily\CodeFont[Scale=0.85]{Consolas}
%\newfontfamily\CodeFont[Scale=0.85]{Anonymous Pro}

\usepackage{luatextra}

\usepackage[english,ngerman,russian]{babel}
\usepackage{csquotes}

% as of now, xindy is broken on my machine right
\usepackage{imakeidx}
\indexsetup{level=\chapter,toclevel=chapter}
\makeindex

\usepackage[backend=biber,style=alphabetic]{biblatex}
%\usepackage[fixlanguage]{babelbib}
\addbibresource{references.bib}
\usepackage[nottoc]{tocbibind}

\usepackage[basic]{complexity}
%\usepackage{xfrac}
%\usepackage{faktor}
\usepackage{amsmath}
%\usepackage{unicode-math}
\usepackage{amsfonts}
\usepackage{amssymb}

\usepackage{commath}
\usepackage{mathtools}

\usepackage{amsthm}
\usepackage{thmtools}
\usepackage{etoolbox}
\usepackage{changepage}

\usepackage{caption}
\usepackage{ragged2e}

\usepackage{graphicx}
%\usepackage[export]{adjustbox}
%\usepackage{epstopdf}
%\epstopdfDeclareGraphicsRule{.tif}{png}{.png}{convert #1 \OutputFile}
%\AppendGraphicsExtensions{.tif}
\usepackage{luamplib}
\usepackage{etoolbox}
\preto\mplibcode{\center\leavevmode}
\appto\endmplibcode{\endcenter}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{subfig}
\usepackage{sidecap}
\usepackage[bottom]{footmisc}

\usepackage{xcolor}
\definecolor{Gray}{gray}{0.9}
\definecolor{blue}{rgb}{0,0,0.3}
\definecolor{green}{rgb}{0,0.3,0}
\definecolor{codeblue}{rgb}{0,0,0.3}
\definecolor{codegreen}{rgb}{0,0.3,0}
\definecolor{codered}{rgb}{0.3,0,0}

\usepackage{listings}
\usepackage{needspace}
\lstset{%
  basicstyle=\CodeFont\footnotesize, %\footnotesize\ttfamily,
  frame=single, %line/leftline/single
  aboveskip=\topsep,
  belowskip=\topsep,
  breakatwhitespace=true,
  showstringspaces=false,
  breaklines=true,
  commentstyle=\itshape\color{codegreen},
  keywordstyle=\bfseries\color{codeblue},
  stringstyle=\color{codered},
  captionpos=t\/
}
\captionsetup[lstlisting]{font=footnotesize}
\newcommand{\mylisting}[2][]{%
  \lstinputlisting[caption={\texttt{\detokenize{#2}}},#1]{#2}%
}

%\usepackage{kantlipsum}
%\usepackage{blindtext}
\usepackage{marginnote}
\newcommand{\annotation}[1]{\marginpar{\small\itshape\color{green}#1}}

\usepackage{booktabs}
\usepackage{longtable}
\usepackage{color, colortbl}
\usepackage{multirow}
\usepackage{varwidth}
\usepackage{pgfplotstable}

\usepackage[title,page,titletoc]{appendix}
\newcommand*{\Appendixautorefname}{Appendix}

\usepackage{verbatim}
\usepackage{cprotect}

\usepackage{afterpage}
%\makeatletter
%\def\verbatim@font{\normalfont\itshape}
%\makeatother
\newcommand\blankpage{%
  \null%
  \thispagestyle{empty}%
  %\addtocounter{page}{-1}%
  \vspace*{\fill}
  \centering
  {\em {\small
  This page would have been intentionally left blank had we not chosen to
  \href{https://en.wikipedia.org/wiki/Recursion}{mention it}.
  }}%
  %\verbatiminput{|"/usr/games/fortune"}
  \vspace{\fill}%
  \newpage
}

\usepackage{abstract}

%\usepackage[toc]{multitoc}
\usepackage[subfigure]{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}

\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}
%\newcommand*{\Cdot}{\raisebox{-0.25ex}{\scalebox{1.2}{$\cdot$}}}
\newcommand*{\Cdot}{\raisebox{-0.30ex}{\scalebox{1.5}{$\cdot$}}}

\usepackage[pdfauthor={M. Deineko},
            pdfproducer={lualatex},
            pdfcreator={LaTeX},
            colorlinks=true,
            linkcolor=blue,
            urlcolor=blue,
            citecolor=blue,
            linktoc=section,
            unicode=true
            ]{hyperref}
\hypersetup{pdftitle=Two Exponential Neighbourhoods}
\usepackage[nameinlink]{cleveref}

\numberwithin{equation}{section}
\numberwithin{figure}{section}
\numberwithin{table}{section}

\declaretheorem[numberwithin=section,style=definition,name=Definition,refname={definition,definitions}]{define}
\declaretheorem[numberwithin=section,style=plain]{theorem}
\declaretheorem[sibling=theorem]{lemma}
\declaretheorem[sibling=theorem]{proposition}
\declaretheorem[sibling=theorem]{corollary}
\declaretheorem[numberwithin=section,style=remark]{remark}
%\BeforeBeginEnvironment{theorem}{\begin{adjustwidth}{1cm}{1cm}}
%\AfterEndEnvironment{theorem}{\endadjustwidth}
%\AfterEndEnvironment{define}{\noindent\ignorespaces}
%\makeatletter
%\def\@endtheorem{\endtrivlist}%
%\makeatother

\let\defstyle\itshape
%\def\defstyle{\itshape}

\begin{document}

\selectlanguage{english}

\title{Two Exponential Neighbourhoods}
\subtitle{Pyramidal and strongly balanced traveling salesman problem and related heuristics --- theory and implementation}
% FIXME: supervisor format ?
% FIXME: title pic / multitoc ?
% FIXME: twosided / book format ?
\input{authors.tex}
\date{\today}

% FIXME: titlepage / spacing ?
\maketitle

% FIXME: better wording / tours family ?
\begin{abstract}
  Pyramidal tours constitute a well known polynomially solvable case of TSP\@.
  In this paper we present a first implementation of a related tours family,
  show extension of both solutions to local search heuristics
  and compare results thus obtained.
\end{abstract}

\thispagestyle{empty}

%\setlength{\cftbeforetoctitleskip}{-2em}
\tocloftpagestyle{empty}
%\afterpage{%
%  \null
%  \thispagestyle{empty}
%  \vspace{\fill}
%  \newpage
%}
\afterpage{\blankpage}
\clearpage
\tableofcontents

%\setlength{\parindent}{0cm}

\afterpage{\blankpage}
\clearpage
\dictum[Sherlock Holmes]{Nothing clears up a case so much as stating it to another person.}
\section{Introduction}

The {\defstyle traveling salesman problem (TSP)} can be colloquially stated as follows:
\index{TSP|see{Traveling Salesman Problem}}
\blockquote{%
  \index{Traveling Salesman Problem|(}
  A traveling merchant (or salesman) wishes to visit each city from a given
  list exactly once, starting from and returning to a select one of the cities
  given.  Assuming that distances between the cities are known and not
  subject to change, what would be the shortest route for him to take?
  \index{Traveling Salesman Problem|)}
}
This well studied problem in combinatorial optimization is known to be
NP-hard \cite{Karp72}; hence, one is interested in efficiently solvable
cases as well as useful heuristics, of which a good number exists.

In this paper we look at two exponential sets of feasible solutions over
which the TSP can be solved in polynomial time and extension of these to
iterative heuristics.  For this, we need to establish some basic
definitions first.

\subsection{Basic definitions and notation}

The TSP, as most mathematical problems, can be modeled in a number of often
equivalent or similar ways, depending on what aspects of the problem are
relevant to the task at hand --- which, for a problem as extensively studied
as this one, results in a great number of common terms which from author to
author can differ ever so slightly.

%Hence we need to establish a set of definitions which we shall try to keep
%precise enough to be able to convey this paper's content clearly,
%while also simple enough so as not to distract from it.
\annotation{Improve description of motivation/justification?}
In what follows, our goal is to establish consistent notation which can be easily
interpreted as a (functional) computer program.

\begin{define}[cities, paths and tours]
Given some $n \in \mathbb{N} \left(n \geq 2\right)$,
let \[\mathcal{N} \coloneqq \mathcal{N}_n \coloneqq \left\{1,\ldots,n\right\}.\]
We will refer to elements of $\mathcal{N}$ as {\defstyle cities}.
A non-empty tuple $\left(p_1,p_2,\ldots,p_m\right)$
of cities is called a {\defstyle path} (of {\defstyle walking length} $m-1$
{\defstyle over} $\mathcal{N}$);
it is called {\defstyle simple} if it contains distinct entries only, with
possible exception of its {\defstyle end points} $p_1$ and $p_m$, i.e. if
\[\left|\left\{p_1,p_2,\ldots,p_{m-1}\right\}\right| =
\left|\left\{p_2,p_3,\ldots,p_{m}\right\}\right| = m-1.\]  We shall refer to
a path of non-zero walking length with distinct end points as an {\defstyle open} path,
one with equal end points --- a {\defstyle closed} one, or a {\defstyle cycle}.
A path of walking length $1$ is also called an {\defstyle edge};
a simple cycle of walking length $n$ is called a {\defstyle tour}.
We then denote by
$\mathcal{P}_n \coloneqq \bigcup_{k \in \mathbb{N}}\mathcal{N}^k$
the set of all paths and by
$\mathcal{T}_n$ --- the set of all tours over $\mathcal{N}$.
\end{define}

We extend the common notion of path {\defstyle concatenation}
to perform a single reduction, as well as to allow for convenient notation for
images under said map defined as infix operator:
\begin{define}[path operations]
  Define {\defstyle path concatenation} to be the following map:
  \[
  %\begin{align}
    \begin{split}
    \oplus \; : & \; {\left( \mathcal{P}_n \cup 2^{\mathcal{P}_n} \right)}^2 \to \mathcal{P}_n \cup 2^{\mathcal{P}_n} \quad \text{(infix)},
    \\
    p \oplus q \coloneqq &
    \begin{cases}
      \left(p_1,\ldots,p_m,q_1,\ldots,q_k\right),
      & p = \left(p_1,\ldots,p_m\right) \in \mathcal{P}_n, \\
      & q = \left(q_1,\ldots,q_k\right) \in \mathcal{P}_n, \\
      & p_m \neq q_1;
      \\
      \left(p_1,\ldots,p_{m-1},q_1,\ldots,q_k\right),
      & p = \left(p_1,\ldots,p_m\right) \in \mathcal{P}_n, \\
      & q = \left(q_1,\ldots,q_k\right) \in \mathcal{P}_n, \\
      & p_m = q_1;
      \\
      \left\{p^\prime \oplus q \; \vert \; p^\prime \in p\right\},
      & p \notin \mathcal{P}_n, q \in \mathcal{P}_n;
      \\
      \left\{p \oplus q^\prime \; \vert \; q^\prime \in q\right\},
      & p \in \mathcal{P}_n, q \notin \mathcal{P}_n;
      \\
      \left\{p^\prime \oplus q^\prime \; \vert \; p^\prime \in p, q^\prime \in q\right\},
      & p \notin \mathcal{P}_n, q \notin \mathcal{P}_n,
    \end{cases}
    \end{split}
  %\end{align}
  \]
  {\defstyle path reversal} as
  \[
    \operatorname{rev} : \mathcal{P}_n \to \mathcal{P}_n, \;
    \left(p_1,p_2,\ldots,p_{m-1},p_m\right) \mapsto \left(p_m,p_{m-1},\ldots,p_2,p_1\right),
  \]
  and {\defstyle path closure} as
  \[
    \overline{\Cdot} : \mathcal{P}_n \to \mathcal{P}_n,
    \quad \left(p_1,\ldots,p_m\right) \mapsto
    \left(p_1,\ldots,p_m\right) \oplus \left(p_1\right),
  \]
  while also allowing for image notation:
  for $P \subseteq \mathcal{P}_n$, let
  \[
    \overline{P} \coloneqq \left\{\overline{p} \mid p \in P\right\}.
  \]
\end{define}

\begin{remark}
  Note that path closure produces a bijection from the set of all simple open paths
  of walking length $n-1$ over $\mathcal{N}_n$ onto $\mathcal{T}_n$.
  Further, $\overline{\mathcal{T}_n} = \mathcal{T}_n$ holds true.
\end{remark}

\begin{define}[costs and distances]
\label{def:cost}
  Given a $n \in \mathbb{N} \left(n \geq 2\right)$ and a matrix $C =
  \left(c_{i,j}\right) \in ~ \mathbb{R}^{n \times n}$, which we shall call
  {\defstyle cost} (or {\defstyle distance) matrix}, we will refer to its
  elements as {\defstyle distances} or {\defstyle weights}.
  Now let \[
    \omega_C: \mathcal{P}_n \to \mathbb{R}, \quad
    \left(p_1,p_2,\ldots,p_m\right) \mapsto \sum_{k=1}^{m-1} c_{p_k,p_{k+1}}.
  \]
  For a path $p$ over $\mathcal{N}_n$ we then call $\omega_C\left(p\right)$ {\defstyle cost} of $p$.
  An edge's cost is also called its {\defstyle weight} (which agrees with the definition above).
\end{define}

\begin{remark}
  We would like to stress here that requiring tours to include a city twice
  explicitly (as end points) allows us to employ same notion of cost for paths and tours,
  which, in turn, will allow for convenient recursive constructions later on.
\end{remark}

\begin{define}[TSP]
\label{def:tsp}
  Given a $n \in \mathbb{N} \left(n \geq 2\right)$,
  $M \subseteq~\mathbb{R}^{n \times n}$ and
  $T \subseteq \mathcal{T}_n, \; T \neq \varnothing$,
  as well as a total order $L$ on $\mathcal{T}_n$,
  we define {\defstyle traveling salesman problem}
  ({\defstyle over $(M,T)$}, also {\defstyle TSP}) to be the map
\[
  \operatorname{tsp}_{L,M,T}: M \to T, \quad
  C \mapsto \min_L \operatorname{tsp^\ast}_{M,T}\left(C\right),
\]
and
\[
  \operatorname{tsp^\ast}_{M,T}: M \to 2^T, \quad
  C \mapsto \argmin_{\tau \in T} \omega_C\left(\tau\right) =
  \left({\omega_C\!}\restriction_T\right)^{-1}\left(\left\{\min \omega_C\left(T\right)\right\}\right).
\]
We call $n$ the TSP's {\defstyle dimension}.
If $M$ is a subset of symmetric matrices (over $\mathbb{R}$), the TSP is called {\defstyle symmetric (sTSP)},
otherwise --- {\defstyle asymmetric (aTSP)}.
\end{define}

\begin{remark}
  Both $\operatorname{tsp^\ast}$ and $\operatorname{tsp}$ are well-defined maps:
  $1 \leq \left|T\right| < \infty$ holds, hence $\;\omega_C$ assumes a minimum value over $T$
  and $\varnothing \notin \operatorname{tsp^\ast}_{M,T}\left(M\right)$.
\end{remark}

\begin{remark}
Frequently, the TSP is defined via a map which provides the sets $M$ and $T$ for every dimension $n$.
We make no such requirement --- however, such an extension is easily established from context, and throughout the rest of this paper we will usually assume that some such dimension is given.
\end{remark}

\begin{remark}
Whenever the sets $M,T$ from above definition are established elsewhere, they are usually omitted from notation.
The pair $(M,T)$ is called a {\defstyle class} or {\defstyle case} of TSP.
\end{remark}

\begin{remark}
Often, the convention is to define TSP to be the symmetric version
\annotation{Reduction remark acceptable without reference?}
(aTSP can also be reduced to sTSP of twice the dimension).
We shall make no such assumption without a prior notice.
\end{remark}

\begin{remark}
It follows from \cref{def:cost,def:tsp} that
$\operatorname{tsp}_{M,T}^\ast\left(C\right) = \operatorname{tsp}_{M,T}^\ast\left(C + \lambda J\right)$
holds true for all $\lambda \in \mathbb{R}$ and $C \in M$,
where $J$ is matrix of ones (of suitable dimension).
Hence we can always assume
\[
  c_{i,j} \geq 0 \quad \forall i,j \in \mathcal{N}
\]
and shall do so henceforth.
\end{remark}

\begin{remark}
\label{rem:order}
  Cost equality naturally induces a partition of $\mathcal{T}_n$ (or its subset $T$ above).
  Usually, we are not interested in all elements of $\operatorname{tsp^\ast}\left(C\right)$
  or its representative given by a particular order $L$ (as produced by $\operatorname{tsp}_L\left(C\right)$)
  but rather in any such tour.
  Hence we make do with the assumption that we may choose any order on $\mathcal{T}_n$ and treat $L$
  as implicit argument to $\operatorname{tsp}$, omitting it from notation where possible ---
  in practice, it is usually given implicitly by construction.
\end{remark}

\begin{remark}
  \annotation{Wording?}
  Also not unusual (and useful in time complexity considerations) is a variation of TSP which returns
  the cost of optimal tour along with or instead of such a tour ---
  transition between these definitions is usually obvious.
  While latter makes the distinction between $\operatorname{tsp}$ and $\operatorname{tsp^\ast}$
  unnecessary and alleviates issues raised in \cref{rem:order},
  it does not provide an obvious solution to the colloquial form of TSP,
  and ignoring said issues only conveniently moves them to particular implementation,
  refusing them proper formal treatment ab ovo.
\end{remark}

\subsection{Exponential neighbourhoods and local search}

Since the TSP in its general form is NP-hard, one is naturally interested in
good heuristics and efficiently solvable cases (of which a significant number does
exist);  this leads us to following general definitions.

\begin{define}[(exponential) neighbourhood]
  A {\defstyle neighbourhood} ({\defstyle in $\mathcal{T}_n$} or {\defstyle over $\mathcal{N}_n$}) is a map
  \[
    F: \mathcal{T}_n \to 2^{\mathcal{T}_n}
    \quad \text{s.t.}\; \tau \in F\left(\tau\right) \ \forall \tau \in \mathcal{T}_n.
  \]
  $F(\tau)$ is also called {\defstyle neighbourhood of} $\tau$.
  Once again, $n$ can be seen either as given dimension or implicit argument to $F$;
  a neighbourhood $F$ is called {\defstyle exponential} if
  \annotation{$\Omega$ or $\Theta$?}
  \[
    \left\vert F(\tau) \right\vert = \Theta(2^n) \qquad \forall \tau \in \mathcal{T}_n.
  \]
\end{define}

\begin{define}[local search]
  Given a neighbourhood $F$ in $\mathcal{T}_n$
  as well as $M \subseteq~\mathbb{R}^{n \times n}$ and $C \in M$,
  we define {\defstyle local search}
  ({\defstyle in} or {\defstyle over $F$}) to be the map
  %\[
  %  \left(M,\mathcal{T}_n\right) \to \mathcal{T}_n^2,
  %  \quad
  %  \left(C,\tau\right) \mapsto l_C
  %\]
  %with
  \[
    l_C :
    \mathcal{T}_n \to \mathcal{T}_n, \quad
    \tau \mapsto \operatorname{tsp}_{M,F(\tau)}\left(C\right).
  \]
  $F$ is said to be {\defstyle polynomially solvable} if $l_{C^\prime}\!\in \P \ \forall C^\prime \in M$ (where time complexity is measured in relation to $n$).
\end{define}

\begin{remark}
\label{rem:localappr}
  Note how for any tour $\tau$, local search defines a map on $M$ via $C^\prime \mapsto l_{C^\prime}\left(\tau\right)$, which can also be seen as approximation of $\operatorname{tsp}_{M,\mathcal{T}_n}$.
\end{remark}

\begin{remark}
\label{rem:nondecr}
\annotation{is ,,for any $C$'' necessary here?}
  For any tour $\tau$, with $\tau \in F\left(\tau\right)$ we also have
  \[
    \omega_C\left(l_C\left(\tau\right)\right) \leq \omega_C\left(\tau\right).
  \]
  %for all cost matrices $C$.
\end{remark}

Combining \cref{rem:localappr,rem:nondecr} naturally yields an iterative improvement heuristic:

\begin{define}[ILS]
\label{def:ils}
  Given a local search function as above and a {\defstyle starting tour} $\tau^\ast$,
  we define {\defstyle iterative} or {\defstyle iterated local search} ({\defstyle ILS})
  to be the map assigning to each $C \in M$ the fixed point of
  \[
    \tau \mapsto
    \begin{cases}
      \tau \quad & \text{if} \; \omega_C\left(l_C\left(\tau\right)\right) = \omega_C\left(\tau\right),
      \\
      l_C\left(\tau\right) & \text{otherwise}
    \end{cases}
  \]
  which is reached by iteration from $\tau^\ast$.
  We shall sometimes call such a fixed point {\defstyle stale iteration}.
\end{define}

\begin{remark}
  In practice, termination conditions employed in ILS may vary and commonly include such
  parameters as number of iterations performed, time elapsed or some cost improvement metric.
\end{remark}

\annotation{Necessary?}
\begin{remark}
  There seems to exist no commonly accepted distinction between local search and iterated local search.
  Often, the former is not required to solve the problem in $F\left(\tau\right)$ but only
  in some small subset of it, or to consist of multiple such improvement steps, which is referred to as ,,anytime'' heuristic.
  Thus, depending on the definition of what constitutes a step, one can potentially be seen as special case of the other.
\end{remark}

\subsection{Tours and permutations}

Given the set $\mathcal{N}_n$ of $n$ cities, let $\mathcal{S}_n$ be the symmetric group (on $\mathcal{N}_n$).

\begin{define}[associated permutation]
  We define $\sigma_{\Cdot}$ (using argument-in-subscript notation) to be the map
  \[
      \sigma_{\Cdot} :
      \mathcal{T}_n \to \; \mathcal{S}_n, \quad
      \tau = \left(p_1, p_2, \ldots, p_n, p_1 \right)
      \mapsto
    \sigma_\tau \coloneqq
    \begin{pmatrix}
      1 & 2 & \cdots & n \\
      p_1 & p_2 & \cdots &  p_n
    \end{pmatrix},
  \]
  and, seeing how this constitutes a bijection, define $\pi$ to be its inverse,
  while letting $\sigma_\tau^{-1}$ denote permutation inverse to $\sigma_\tau$.
  %\[
  %  \pi & \coloneqq \left(\sigma_{\Cdot}\right)^{-1}.
  %\]
  We say then that $\tau$ and $\sigma_\tau$ are {\defstyle associated} with one another.
\end{define}

\begin{remark}
  We note here that function composition is default group operation on $\mathcal{S}_n$ and
  therefore can be omitted from notation where it is convenient and does not cause unnecessary ambiguity.
\end{remark}

The map $\pi$, being a bijection, conveniently provides a natural extension
of cost to $\mathcal{S}_n$ via $\omega_C \circ \pi$:
\begin{define}[cost of permutation]
  For a cost matrix $C$ of dimension $n$, we shall extend $\omega_C$ to $\mathcal{P}_n \cup \mathcal{S}_n$
  by setting, for any $\rho \in \mathcal{S}_n$,
  \[
    \omega_C\left(\rho\right) \coloneqq \omega_C\left(\pi\left(\rho\right)\right).
  \]
\end{define}

Similarly, we can use the map $\sigma_{\Cdot}$ for following convenient notation:
\begin{define}[action of $\mathcal{S}_n$]
\label{def:actions}
  For $\tau \in \mathcal{T}_n, \rho \in \mathcal{S}_n,
       C \in M \subseteq \mathbb{R}^{n \times n}, T \in 2^{\mathcal{T}_n}$,
  we define
  \begin{align*}
    \tau \rho & \coloneqq \sigma_\tau \rho, \\
    \rho \, \tau & \coloneqq \rho \, \sigma_\tau, \\
    \rho \, C & \coloneqq \left(c_{\rho\left(i\right),\rho\left(j\right)}\right), \\
    \rho M & \coloneqq \left\{ \rho \, \widehat{C} \mid \widehat{C} \in M \right\}, \\
    \rho \, T & \coloneqq \pi\left(\left\{ \rho \, \sigma_\eta \mid \eta \in T \right\}\right).
  \end{align*}
\end{define}

If we consider $\rho \, \tau$ to be the tour $\tau$ over reordering of cities corresponding to $\rho$,
and $\tau \rho$ to be a reordering of the tour $\tau$, following result becomes intuitively agreeable:

\begin{proposition}
\label{prop:rotinv}
\annotation{Remove ,,circular''?}
  For any {\defstyle circular permutation} $\rho \in \left<\left(1 \; 2 \; \cdots \; n \right)\right>$,
  \[
    \omega_C\left(\tau\right) = \omega_C\left(\tau \rho\right)
  \]
  holds true for all $\tau \in \mathcal{T}_n$ and all $C \in \mathbb{R}^{n \times n}$.
\end{proposition}
\begin{proof}
  Consider following natural isomorphism between $\mathbb{Z}/n\mathbb{Z}$ and $\mathcal{N}_n$:
  for $i \in \mathbb{Z}$, let
  \[
    d\left(i\right) \coloneqq \left(\left(i-1\right)\operatorname{mod} n\right)+1.
  \]
  We have $d\left(\mathbb{Z}\right) = \mathcal{N}_n$,
  and $d\restriction_{\mathcal{N}_n} = \operatorname{id}_{\mathcal{N}_n}$
  is trivially a bijection (as is $\rho$); further,
  \begin{align}
    \label{eq:add}
    d\left(x+y\right) =
    d\left(d\left(x\right) + d\left(y\right)\right)
    \quad \forall x \in \mathbb{Z} \; \forall y \in \mathbb{Z},
  \end{align}
  and with $d\left(n+1\right) = 1$ we can now write the cost function from \cref{def:cost} as
  \begin{equation}
  \label{eq:cost}
    \omega_C\left(\tau\right) =
    \sum_{i=1}^n c_{\sigma_\tau\left(i\right),\sigma_\tau\left(d\left(i+1\right)\right)}.
  \end{equation}
  %i.e.\ $d$ is the natural mapping of addition from %$\faktor{\mathbb{Z}}{n\mathbb{Z}}$ onto $\mathcal{N}_n$.
  %$\mathbb{Z}/n\mathbb{Z}$ onto $\mathcal{N}_n$.
  We also note that \exists $K \in \mathcal{N}_n$ s.t.\ 
  $\rho\left(i\right) = d\left(i+K\right) \; \forall i \in \mathcal{N}_n$,
  and, using \cref{eq:add}, obtain
  \begin{align}
    \label{eq:addadd}
    \begin{split}
    \rho \left(d\left(i+1\right)\right)
    & =
    d\left(d\left(i+1\right)+K\right) =
    d\left(d\left(i+1\right)+d\left(K\right)\right) =
    d\left(i+1+K\right) =
    \\
    & =
    d\left(d\left(i+K\right)+d\left(1\right)\right) =
    d\left(d\left(i+K\right)+1\right) =
    %\\
    %& =
    d\left(\rho\left(i\right)+1\right)
    \end{split}
  \end{align}
  for any city $i$.
  It now follows that
  \begin{align*}
    \omega_C\left(\tau \rho\right) =
    \omega_C\left(\pi\left(\sigma_\tau \circ \rho\right)\right)
    & \stackrel{\eqref{eq:cost}}{=}
    \sum_{i=1}^n c_{\sigma_\tau\left(\rho\left(i\right)\right),\sigma_\tau\left(\rho\left(d\left(i+1\right)\right)\right)}
    =
    \\
    & \stackrel{\eqref{eq:addadd}}{=}
    \sum_{k=1}^n c_{\sigma_\tau\left(k\right),\sigma_\tau\left(d\left(k+1\right)\right)}
    \stackrel{\eqref{eq:cost}}{=}
    \omega_C\left(\tau\right).
  \end{align*}
\end{proof}

%\begin{remark}
%\label{rem:touract}
%\annotation{TODO: elaborate both sides, add transformations}
%  Any tour $\tau^\prime$ can thus be seen as a permutation of cities and act on other tours via
%  $\tau \mapsto \pi\left(\sigma_\tau \circ \sigma_{\tau^\prime}\right)$.
%\end{remark}

\begin{remark}
  \annotation{Wording?}
  This shows, in particular, how resticting the tour set in the TSP to a fixed starting city
  does not necessarily signify a qualitative restriction of solutions set.
\end{remark}

We now want to establish a connection between permutations of cities, reorderings of tours and
solutions to the TSP.

\begin{lemma}
\label{lemma:ordermat}
  For any $\rho \in \mathcal{S}_n, C \in \mathbb{R}^{n \times n}, \tau \in \mathcal{T}_n$,
  \[
    \omega_C\left(\rho\,\tau\right) = \omega_{\rho\,C}\left(\tau\right)
  \]
  holds true.
\end{lemma}
\begin{proof}
  Borrowing definition of $d$ from the proof of \cref{prop:rotinv},
  and using \cref{eq:cost} along with \cref{def:actions}, we obtain
  \begin{align*}
    \omega_{\rho\,C}\left(\tau\right) =
    \sum_{i=1}^n c_{\rho\left(\sigma_\tau\left(i\right)\right),\rho\left(\sigma_\tau\left(d\left(i+1\right)\right)\right)} =
    \omega_C\left(\rho \circ \sigma_\tau\right) =
    \omega_C\left(\rho\,\tau\right).
  \end{align*}
\end{proof}

\begin{corollary}[reordered TSP]
\label{cor:reorder}
  For any $\rho \in \mathcal{S}_n, C \in M \subseteq \mathbb{R}^{n \times n}, \tau \in \mathcal{T}_n$,
  \begin{align*}
  \begin{split}
    \operatorname{tsp}^\ast_{M,\rho T}\left(C\right)
    & =
    \rho \: \operatorname{tsp}^\ast_{\rho M,T}\left(\rho\,C\right),
    \\
    \operatorname{tsp}_{M,\rho T}\left(C\right)
    & =
    \pi\big( \rho \: \operatorname{tsp}_{\rho M,T}\left(\rho\,C\right) \big).
  \end{split}
  \end{align*}
  %(the latter for a pair of suitable orderings of tours).
  %% any pair congruent via \rho
\end{corollary}
\begin{proof}
  Using \cref{lemma:ordermat} and \cref{def:tsp}, we obtain
  \begin{align*}
    \begin{split}
    \operatorname{tsp}^\ast_{\left\{\rho\,C\right\},T}\left(\rho\,C\right)
    & =
    \argmin_{\tau \in T} \omega_{\rho\,C}\left(\tau\right) =
    \argmin_{\tau \in T} \omega_{C}\left(\rho\,\tau\right) =
    \\
    & =
    \rho^{-1} \: \argmin_{\rho\tau \in \rho T} \omega_{C}\left(\rho\,\tau\right) =
    \rho^{-1} \: \operatorname{tsp}^\ast_{\left\{C\right\},\rho T}\left(C\right),
    \end{split}
  \end{align*}
  from which the rest follows.
\end{proof}

\subsection{Tour sets as neighbourhoods}

%Suppose that we can solve the TSP efficiently over some fixed set of tours $T$ for
%arbitrary cost matrices.

%We have seen how a set of tours $T$ can be seen as a set of permutations of the cities,
%or permutations of the canonical tour $\pi\left(\operatorname{id}\right)$,
%which is not necessarily an element of $T$.

Given a non-empty set of tours $T$, we can choose some (any) element $\tau^\ast \in T$
and consider $T$ to be a set of permutations of $\tau^\ast$ ---
its action then defines a neighbourhood in $\mathcal{T}_n$:

\begin{define}[induced neighbourhood]
  \label{def:induced}
  Given a set of tours $T$ and a tour $\tau^\ast \in T$,
  define $F_T$ to be the map
  \[
    F_T: \mathcal{T}_n \to 2^{\mathcal{T}_n}, \quad
    \tau \mapsto
    \pi \left(
      \left\{ \sigma_{\tau} \circ \sigma_{\tau^\ast}^{-1} \circ \sigma_{\tau^\prime}
              \mid \tau^{\prime} \in T\right\}
    \right)
    =
      \left(\sigma_{\tau} \circ \sigma_{\tau^\ast}^{-1}\right) T.
  \]
  We call $F_T$ {\defstyle neighbourhood induced by} $T$ (and $\tau^\ast$).
\end{define}

\begin{figure}[bht]
  \centering
  \includegraphics[width=0.49\textwidth]{../plot/build/ext-1.mps}
  \caption{A non-empty set of tours $T$ induces a neighbourhood $F_T$.}
\end{figure}

\begin{remark}
  It is quickly verified that
  $\tau \in F_T\left(\tau\right) \; \forall \tau \in \mathcal{T}_n,$
  i.e.\ $F_T$ is in fact a neighbourhood according to our definition.
  We further have $F_T\left(\tau^\ast\right) = T$.
\end{remark}

\begin{remark}
  We deliberately omit the choice of $\tau^\ast$ from notation of induced neighbourhood,
  treating it as implicit parameter --- which is usually established along with the set $T$.
\end{remark}

\begin{remark}
  If we now can solve the TSP efficiently over a fixed set of tours $T$ (for arbitrary cost matrices),
  combining \cref{def:induced} and \cref{cor:reorder} immediately allows us to
  construct local search over $F_T$, namely
  \[
    l_C\left(\tau\right) = \pi\left(\rho \, \operatorname{tsp}_{\rho M,T}\left(\rho\, C\right)\right),
    \quad
    \text{where}\; \rho = \sigma_\tau \sigma_{\tau^\ast}^{-1},
  \]
  and choosing $\tau^\ast$ to be the starting tour in \cref{def:ils} then yields iterated local search.
  %
  % OUR CODE: see tspsearch/itersearch.sml
  %
  %   inv_order = \sigma_{\tau^\ast}^{-1}
  %   lookup t = \sigma_t \circ inv_order
  %   map x y = x o y for permutation y
  %
\end{remark}

\clearpage
\dictum[L. Peter Deutsch]{To iterate is human, to recurse divine.}
%\dictum[Honore de Balzac]{To get a traveling salesman drunk is the height of impossibility.}
\annotation{TODO FROM HERE}
\section{Theory}

\subsection{Pyramidal tours}

\annotation{Who was first?}
Pyramidal tours constitute a classic example of a TSP class where an
optimum solution for an exponential tours set (also, a neighbourhood) can
be found in polynomial time \cite{bellman,gilmore}.

\begin{define}
  A path $\pi = \left( k_1, \ldots, k_m \right)$ is called {\bfseries simple}
  if it consists only of distinct nodes, except, possibly, end nodes $k_1$ and $k_m$.
  In case where $k_1 = k_m$ we shall call such a path {\bfseries closed}.
\end{define}
\begin{define}[Pyramidal Tour]
  A simple path $\pi = \left( k_1, \ldots, k_p, l_1, \ldots, l_q \right), \; p+q \geq 1,$
  is called {\bfseries pyramidal} if
  $k_i < k_j, l_i > l_j \; \forall i < j$.
  A (simple) closed path is called a {\bfseries tour}.
\end{define}
\noindent
Since all tours associated with $S_n$ have the form $\left(1, k_1, \ldots,
k_p, n, l_1, \ldots, l_q, 1 \right)$, it follows that the number of all
such tours is $2^{n-2}$.  Also note how the graph of such a permutation
considered a function ${\mathbb Z}_n \rightarrow {\mathbb Z}_n$ resembles a
pyramid.

\annotation{Here a nice figure of a pyramidal tour and a pyramid shall be.}
\begin{figure}[htbp]
\centering%
\begin{mplibcode}
  beginfig(0)
    pair p[];
    p1 = (0,0); p2 = (100,0); p3 = (200,0); p4 = (300,0); p5 = (400,0);
    pair c[];
    c1 = (50,20); c2 = (210,30); c3 = (250,-10); c4 = (100,-20);
    path a;
    a = p1 .. controls c1 ..
        p2 .. controls c2 ..
        p4 ..
        p5 .. controls c3 ..
        p3 ..  controls c4 ..
        cycle ;
    for i = 1 upto length a:
      dotlabel.top(decimal i, p[i]);
      drawarrow subpath (i-1,i) of a withcolor 0.2;
    endfor
  endfig;
\end{mplibcode}
\ 
\caption{A pyramidal tour over $K_5$.}
\end{figure}

\subsection{Recursion and complexity}

It turns out that for this particular exponential neighbourhood a simple dynamic programming
scheme delivers a polynomial solution.
\annotation{Is there any difference at all between sTSP and aTSP here?}
(For simplicity, we shall consider symmetric TSP (sTSP).)
For a sTSP of size $n$, let
\begin{align*}
  \Phi\left(i,j\right) \ldots \; & \text{shortest pyramidal path} \left(i,k_1,\ldots,k_p,j\right) \\
                      & \text{s.t.} \; \left\{ k_1,\ldots,k_p \right\} = \left\{ k,\ldots,n \right\} \\
                      & \text{where} \; k = \max\left\{i,j\right\}+1.
\end{align*}
One can easily see that $\Phi(1,1)$ is the optimum of all pyramidal tours in $S_n$ (one-based).
\[
  \Phi\left(i,n\right) = \left(i,n\right) \; \text{and} \; \Phi\left(n,j\right) = \left(n,j\right).
\]
\annotation{A construction illustration would be in order here.}
Now note that one can build an arbitrary pyramidal path by considering nodes' positions in increasing order:
given a partial tour (a pyramidal path) $\left(1,\ldots,i,j,\ldots,1\right)$ which increases to $i$ and
decreases from $j$, the next element ($\max\left\{i,j\right\}+1$) has to lie adjacent to $i$ or $j$.
Since every pyramidal tour over $K_n$ can be constructed in this manner, it follows that
\begin{gather*}
  \Phi\left(i,j\right) = \argmin_{\tau \in T}\mathfrak{w}\left(\tau\right) \\
  \text{where} \; T = \left\{ \left( i,k \right) \oplus \Phi(k,j), \Phi(i,k) \oplus \left( k,j \right) \right\} \\
  \text{and} \; \oplus \; \ldots \; \text{path concatenation}.
\end{gather*}
We hence arrive at
\begin{theorem}
  For $K_n$, amongst $2^{n-3}$ pyramidal tours an optimum can be found in $\mathcal O(n^2)$ steps.
\end{theorem}
\begin{proof}
  For $K_n$, computing the optimum now requires computing not more than $\Phi\left(i,j\right)$
  for all pairs $\left(i,j\right)$.
\end{proof}

\begin{figure}[htbp]
\centering
\includegraphics[width=0.59\textwidth]{../plot/build/trace_pyr.pdf}
\caption{A trace of our implementation's pyramidal search graph traversal over $K_5$.}
\end{figure}

\annotation{Demidenko conditions: is a description necessary/interesting?}
While determining if a given TSP instance is pyramidal is NP-hard \cite{baki},
a number of polynomially testable classes which are pyramidally solvable exist \cite{baki,gilmore} ---
still, those are not widely common.

Pyramidal search can also be extended to a local search heuristic:
note first how the tour obtained depends on node numbering.
Now let $\operatorname{pyr}(C)$ denote best pyramidal tour given a distance matrix $C$
and, given a tour $\tau$, $\sigma_\tau \left(C\right)$ be the permutation associated with $\tau$
applied to rows and columns of $C$ (i.e. renumbering of nodes).
Let
\[
  h_C \; : \;
    \tau \mapsto \left(
      \sigma_{\tau}^{-1} \circ
      \operatorname{pyr} \circ
      \sigma_{\tau}
    \right)
    \left( C \right).
\]
Then $h_C\left(\left(1,2,\ldots,n,1\right)\right) = \operatorname{pyr}\left(C\right)$.
Since $\left(1,2,\ldots,n,1\right)$ is a pyramidal tour,
\[
  \operatorname{len} \circ h_C \leq \operatorname{len}
\]
holds everywhere.
In this way, iterating from $\left(1,2,\ldots,n,1\right)$ to a fixed point of $h_C$ yields a
local search heuristic.

It had been shown \cite{belperm} that we can significantly improve on this by enhancing
$\operatorname{pyr}$ to choose from $n$ shortest pyramidal tours obtained by applying
cyclic permutations to initial node ordering.

\subsection{Four point conditions exponential neighbourhoods}

\subsection{Strongly balanced tours}

\annotation{Balanced tours interesting?}
Another class of sTSP is the {\em Relaxed Supnick TSP} \/(RS-TSP), which is
obtained by restricting considered instances via a simple four-point
condition:
\[
  c_{ik} + c_{jl} \leq c_{il} + c_{jk} \quad \forall \; 1 \leq i < j < k < l \leq n,
\]
where $\left(c_{ij}\right)$ is the distance matrix.

While it has been shown that RS-TSP is NP-hard, an exponential subset of
said problem which is polynomially solvable has also been found.  Herein we
present first implementation of the solution, which bears distinct similarity
to pyramidal TSP.

\annotation{Add supplementary pictures/explanation.}
We shall define our neighbourhood through explicit tour construction.  For brevity,
let $\left[a,b\right]$ describe a (simple) path $\left<a,\ldots,b\right>$.
\begin{define}[Strongly Balanced Tour]
  Consider following family of path sets:
  \begin{itemize}
    \item $\mathcal T_1 = \left\{\left<1\right>\right\};$
    \item $\mathcal T_n = \bigcup_{\tau \in \mathcal T_{n-1}}
      \left(
      \left\{
          \operatorname{add}\left(\tau,n\right),
          \operatorname{app}\left(\tau,n\right)
      \right\} \cup
      \operatorname{merge}\left(\tau,n\right)
      \right)
    $
    where
    \begin{align*}
      \operatorname{add}\left(\tau,n\right) = & \; \tau \cup \left\{\left<n\right>\right\}; \\
      \operatorname{app}\left(\tau,n\right) = & \;
        \tau \setminus \left\{\left[a_1,a_2\right]\right\}
        \cup \left\{\left<n\right>\oplus\left[a_1,a_2\right]\right\} \\
        & \; \text{for} \; \tau = \left\{ \left[a_i,a_{i+1}\right] \right\}_{i \in I}
        \text{and} \; a_1 = \min_{k \in I \cup 1+I}\left\{a_k\right\}, \\
      \operatorname{merge}\left(\tau,n\right) = & \;
        \left\{
          \tau \setminus \left\{\left[a_1,a_2\right],\left[a_3,a_4\right]\right\}
          \cup \left\{\left[a_2,a_1\right]\oplus\left<n\right>\oplus\left[a_3,a_4\right]\right\}
        \right\} \\
        & \; \text{for} \; \tau, a_1 \; \text{as above,}
          \; a_3 = \min_{\substack{k \in I \cup 1+I\\\ k \neq 1, k \neq 2}}\left\{a_k\right\}.
    \end{align*}
    Here multiple appearances of $[.,.]$ notation with same indexes refer to same paths.
    Also note how $\operatorname{merge}\left(\tau,n\right)$ is empty if there is no $a_3$
    satisfying the constraints.

  \end{itemize}
  An element of $\mathcal T_n$ is said to be {\bfseries strongly balanced}.
  A tour $\left<k_1,\ldots,k_n,k_1\right>$ is said to be {\bfseries strongly balanced} if
  $\left<k_1,\ldots,k_n\right> \in {\mathcal T}_n$.
\end{define}

\subsection{Strongly balanced tours and linear time conjecture}

\annotation{Interesting?}
It can subsequently be shown that the set of strongly balanced tours contains optimal solution
to TSP restricted to Relaxed Supnick matrices which additionaly satisfy
\[
  c_{il} + c_{jk} + c_{km} \geq c_{ik} + c_{jm} + c_{kl}
  \quad \forall i < j < k < l < m
\]
and that this condition can be checked in quadratic time.

\annotation{Details?}
If we further restrict this set by
\[
  c_{ji} + c_{kl} \leq c_{jl} + c_{ki} \quad \forall i<j, \; j+h \leq k < l
\]
for a given constant $h$, then we can show that the optimum can be found
amongst balanced tours for which number of paths of each element of $\mathcal T$
does not exceed $h/2 + 1$, and for such families size of ${\mathcal T}_n$ is bounded
by a constant for given $h$ \cite{fpneighb,fpclass}.

Number of unique node types, which presents upper bound for tree width, can
be seen in \autoref{tbl:nodeTypes}.  A breadth-first search implementation
could be used to naturally compute the tree width.

\annotation{Show how number of tours is $\Omega(2^n)$.}
Noting how the definition of strongly balanced tours naturally
yields a dynamic programming recursion, this results in a linear time
solution for the given exponential neighbourhood.

\setlength{\aboverulesep}{0pt}
\setlength{\belowrulesep}{0pt}
\renewcommand{\tabcolsep}{9pt}
\setlength{\extrarowheight}{1.1ex}
\newcolumntype{g}{>{\columncolor{Gray}}c}

\begin{table}[htpb]
\centering
    \mbox{%
      \pgfplotstabletypeset[
        col sep=space,
        std=-10:10,
        every head row/.style={output empty row},
        every head row/.style={%
          before row={\toprule},
          after row={\midrule}
        },
        display columns/0/.style={%
          column name={\bfseries Node size limit},
          column type={g}
        },
        display columns/1/.style={%
          column name={\bfseries Node types},
          column type={r}
        },
        display columns/2/.style={%
          column name={\bfseries Stable at depth},
          column type={g}
        },
        every last row/.style={after row=\bottomrule},
        %multicolumn names,
      ]{../plot/data/num\string_types.csv}%
    }
\caption{Number of node types encountered.  This seems to closely reflect the tree width -- and thus runtime -- growth.}%
\label{tbl:nodeTypes}%
\end{table}

\begin{figure}[htbp]
\makebox[\textwidth][c]{%
  \includegraphics[width=1.21\textwidth]{../plot/build/trace_bal.pdf}
}
\caption{%
  A trace of our implementation's strongly balanced search graph traversal over $K_8$.  Here, maximum node size is 2.
}
\end{figure}

Having constructed a linear solution to an exponential problem class, quite
naturally the question arises whether this would constitute a good heuristic
in general case.
\annotation{Check: $\mu$ prepended or appended?}
To try and answer this, we have taken the same path as in pyramidal case.
Note that to account for strongly balanced tours structure, we have to
\begin{itemize}
  \item replace $\sigma_\tau$ by $\sigma_\tau \circ \sigma_\mu$
        in fixed point iteration, where $\mu = \left<\ldots,5,3,1,2,4,\ldots\right> \in S_n$;
  \item also apply $\mu$ (we also added $\mu$ mirrored)
        before considering cyclic permutations while also considering the identity permutation.
\end{itemize}

Results of our experiments are presented in next section
(where {\em adaptive search} \/refers to number of considered permutations growing at stale iterations
and {\em flipflop search} \/refers to alterating between pyramidal and strongly balanced search in each iteration).

\subsection{Local search and flowers}

\clearpage
\dictum[Donald Knuth]{You’re bound to be unhappy if you optimize everything.}
%\dictum[Edward V Berard]{Walking on water and developing software from a specification are easy if both are frozen.}
\section{Implementation}

\subsection{Key features}
\annotation{TODO}

Written in {\ttfamily Standard ML}.
Usable via SML REPL, standalone executable or shared library.
Tested under multiple software (see \autoref{app:compiler}) and OS/hardware platforms --
Linux (amd64) and Windows (x86) (MinGW-crosscompiled).

\annotation{Tradeoff illustration: provide LOC count?}
General dynamic programming results implementation via search graph traversal (simple depth-first search),
making a tradeoff between performance and extendibility.
BFS could be somewhat faster, but for our research dfs is enough.
Memoization via hash tables.

\annotation{Can we rename repo?}
This project's sources are available
\href{https://bitbucket.org/mad_hatter/rstsp/}{online}\footnote{\url{https://bitbucket.org/mad_hatter/rstsp/}}.

\subsection{Runtime behaviour}
\annotation{TODO}
\annotation{Describe \autoref{fig:benchRAND}.}

Clearly pronounced linear runtime for str.~balanced search, apparently heavy overhead penalty.
Pyramidal faster but str.~balanced eventually takes over.
See \autoref{fig:benchRAND}.
Memory usage not seriously measured, since bottleneck here is runtime.

\begin{figure}[htbp]
\null\hfill%
\subfloat[higher node sizes]{%
  \includegraphics[width=0.49\textwidth]{../plot/build/mlton_time_random_low.pdf}
}\hfill\null
\null\hfill%
\subfloat[medium node sizes]{%
  \includegraphics[width=0.49\textwidth]{../plot/build/mlton_time_random_fast.pdf}
}\hfill\null\\
\null\hfill%
\subfloat[low node sizes]{%
  \includegraphics[width=0.59\textwidth]{../plot/build/mlton_time_random_steady.pdf}
}\hfill\null\\
\null\hfill%
\subfloat[pyramidal vs str.~balanced/m3]{%
  \includegraphics[width=0.49\textwidth]{../plot/build/mlton_time_random_med.pdf}
}\hfill\null
\null\hfill%
\subfloat[pyramidal vs str.~balanced/m4]{%
  \includegraphics[width=0.49\textwidth]{../plot/build/mlton_time_random_hi.pdf}
}
\hfill\null
\caption{Single traversal running times (Linux 3.10.17 ({\ttfamily x86\_64}) @ i5-2520M).}
\label{fig:benchRAND}
\end{figure}

\subsection{Tour benchmarks}

\annotation{TODO}
Describe results, add Relaxed Supnick matrices benchmarks (!),
prettier (also, split) histograms?, plot iterations behavior? -- see \autoref{fig:benchTSPLIB}.

In what limited testing we have done, pyramidal still performs better.

For str.~balanced: adaptive search seems to perform better
than always choosing from $2n+1$ specific permutations.

\begin{figure}[htbp]
\null\hfill%
\subfloat[random --- tour length]{%
  \includegraphics[width=0.69\textwidth]{../plot/build/random_val.pdf}
}\hfill\null\\
\null\hfill%
\subfloat[tsplib \& vlsi --- tour quality]{%
  \includegraphics[width=0.69\textwidth]{../plot/build/tsplib_val.pdf}
}\hfill\null\\
\null\hfill%
\subfloat[tsplib \& vlsi --- time needed]{%
  \includegraphics[width=0.69\textwidth]{../plot/build/tsplib_time.pdf}
}\hfill\null
\caption{Benchmarks --- small instances.}
\label{fig:benchTSPLIB}
\end{figure}

\clearpage
\dictum[Arthur Bloch]{Enough research will tend to support your conclusions.}
\section{Conclusions}

\subsection{Results obtained}
\annotation{TODO}
First implementation of str.~balanced search.
Some benchmarks.
Preprocessing offers no gain.

\begin{figure}[htbp]
%\begin{wrapfigure}{r}{0.5\textwidth}
\centering
\includegraphics[width=0.54\textwidth]{./tsp.png}
\caption*{\captionsize Source: \small \url{https://xkcd.com/399/}.}
%\end{wrapfigure}
\end{figure}

\subsection{Areas for further research}
\annotation{TODO}

Are these heuristics better for aTSP\@?
Untested: other metrics or higher dimensions, dedicated implementations' performance.
Further heuristics combinations.
Branch cutting.
Different permutations set for str.~balanced tours?

\subsection{Dynamic programming algorithms and concurrency}
\annotation{TODO}

Dedicated implementations (pyramidal: bottom up easy) fast, but not always feasible (str.~balanced: machine-generated).
Naive concurrency (see the {\ttfamily experimental} code) not easily applicable in general case (dense search tree).
Potentially fruitful approaches: tuple spaces, message passing languages, etc
(PolyML/Linda?, manticore, jocaml, mythryl, aliceml, clojure/clotilde, scala/akka, $\ldots$).

%\input{problem1.tex}

%\appendix
%\addcontentsline{toc}{chapter}{Appendices}
%\makeatletter
%\addtocontents{toc}{\let\protect\l@chapter\protect\l@section}
%\makeatother
%\chapter{First Appendix}
%\chapter{Second Appendix}

\clearpage
\begin{appendices}

\makeatletter
\addtocontents{toc}{\let\protect\l@chapter\protect\l@section}
\makeatother

%\section{Code Index}
%\lstlistoflistings%

\section{Shared Library Interface}
\label{app:so}

\needspace{5\baselineskip}
\mylisting[
  caption={[FFI usage example]FFI usage example.},
  firstline=8,fontadjust,language=C,
  label=lst:so]{../src/rstsp/librstsp/test.c}

\section{Sample REPL Session}

%\input{testapp.tex}

\section{Compiler Support}
\label{app:compiler}
\input{sml-support.tex}

\end{appendices}

%\printindex
\printbibliography%

\end{document}

